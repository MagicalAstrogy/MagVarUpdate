{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://mag-variable-update/./src/variable_def.ts","webpack://mag-variable-update/external module \"https://testingcf.jsdelivr.net/npm/mathjs/+esm\"","webpack://mag-variable-update/./src/schema.ts","webpack://mag-variable-update/./src/settings.ts","webpack://mag-variable-update/./src/function.ts","webpack://mag-variable-update/./src/update_descriptions.ts","webpack://mag-variable-update/./src/variable_init.ts","webpack://mag-variable-update/./src/button.ts","webpack://mag-variable-update/./src/export_globals.ts","webpack://mag-variable-update/./src/main.ts"],"sourcesContent":["// 模板类型定义\nexport type TemplateType = StatData | StatData[] | any[];\n\n// StatData 的元数据类型定义\nexport type StatDataMeta = {\n    extensible?: boolean;\n    recursiveExtensible?: boolean;\n    required?: string[];\n    template?: TemplateType; // 模板定义，用于自动填充新元素\n    [key: string]: unknown;\n};\n\nexport type JSONPrimitive = string | number | boolean | null;\n\n// StatData 类型定义 - 支持嵌套对象和数组，可以有 $meta 属性\nexport type StatData = {\n    [key: string]: StatData | JSONPrimitive | (StatData | JSONPrimitive)[];\n} & {\n    $meta?: StatDataMeta;\n    $arrayMeta?: boolean;\n};\n\n// Schema 节点类型定义\nexport type SchemaNode = ObjectSchemaNode | ArraySchemaNode | PrimitiveSchemaNode;\n\n// 对象类型的 Schema 节点\nexport type ObjectSchemaNode = {\n    type: 'object';\n    properties: {\n        [key: string]: SchemaNode & { required?: boolean };\n    };\n    extensible?: boolean;\n    template?: TemplateType; // 新增属性的模板\n    recursiveExtensible?: boolean;\n};\n\n// 数组类型的 Schema 节点\nexport type ArraySchemaNode = {\n    type: 'array';\n    elementType: SchemaNode;\n    extensible?: boolean;\n    template?: TemplateType; // 新增元素的模板\n    recursiveExtensible?: boolean;\n};\n\n// 原始类型的 Schema 节点\nexport type PrimitiveSchemaNode = {\n    type: 'string' | 'number' | 'boolean' | 'any';\n};\n\n// ValueWithDescription 类型 - 用于表示带描述的值\nexport type ValueWithDescription<T> = [T, string];\n\nexport function assertVWD(\n    _flag: boolean,\n    _v: StatData | JSONPrimitive | (StatData | JSONPrimitive)[]\n): asserts _v is ValueWithDescription<StatData | JSONPrimitive> {}\n\nexport function isValueWithDescription(value: unknown): boolean {\n    return Array.isArray(value) && value.length === 2 && typeof value[1] === 'string';\n}\n\nexport function isValueWithDescriptionStatData(\n    value: StatData | JSONPrimitive | (StatData | JSONPrimitive)[]\n): value is ValueWithDescription<StatData | JSONPrimitive> {\n    return Array.isArray(value) && value.length === 2 && typeof value[1] === 'string';\n}\n\n// 类型守卫函数\nexport function isArraySchema(value: SchemaNode): value is ArraySchemaNode {\n    return value.type === 'array';\n}\n\nexport function isObjectSchema(value: SchemaNode): value is ObjectSchemaNode {\n    return value.type === 'object';\n}\n\nexport function isPrimitiveSchema(value: SchemaNode): value is PrimitiveSchemaNode {\n    return (\n        value.type === 'string' ||\n        value.type === 'number' ||\n        value.type === 'boolean' ||\n        value.type === 'any'\n    );\n}\n\nexport type RootAdditionalProps = {\n    strictTemplate?: boolean;\n    concatTemplateArray?: boolean;\n    strictSet?: boolean;\n};\n\nexport type RootAdditionalMetaProps = {\n    $meta?: StatDataMeta & RootAdditionalProps;\n};\n\nexport type MvuData = {\n    // initialized_lorebooks 从字符串列表变为记录对象\n    // 这样可以为每个知识库存储元数据，例如初始化的标记变量\n    /** 已初始化的 lorebook 列表 */\n    initialized_lorebooks?: Record<string, any[]>;\n\n    /**\n     * 状态数据 - 存储实际的变量值\n     * 支持嵌套对象结构，通过路径（如 \"player.health\"）访问\n     * $internal 属性在更新过程中临时存储 display_data 和 delta_data 的引用\n     *\n     * 更新逻辑：\n     * 1. 普通值：直接更新为新值\n     * 2. ValueWithDescription 类型：更新数组的第一个元素（实际值），保留第二个元素（描述）\n     * 3. 数字类型：自动将字符串新值转换为数字\n     */\n    stat_data: StatData & RootAdditionalMetaProps & { $internal?: InternalData };\n\n    /**\n     * 显示数据 - 存储变量变化的可视化表示\n     * 格式：\"{旧值}->{新值} ({原因})\"\n     * 例如：\"100->80 (受到伤害)\"\n     *\n     * 默认情况下包含完整的 stat_data ，但是在变更后，会将变更的元素变为上面含原因的表示。\n     * 更新时机：每次 stat_data 中的值发生变化时同步更新\n     * 用途：在UI中展示变量的变化历史，让用户了解数值是如何变化的\n     */\n    display_data?: Record<string, any>;\n\n    /**\n     * 增量数据 - 存储本次更新中发生变化的变量\n     * 格式：与 display_data 相同，\"{旧值}->{新值} (原因)\"\n     *\n     * 更新时机：\n     * - 在 updateVariables 开始时初始化为空对象\n     * - 每次变量更新时记录变化\n     * - 更新结束后保存到消息的 variables 中\n     *\n     * 用途：仅显示当前消息/操作中实际发生变化的变量，而不是所有历史变化\n     */\n    delta_data?: Record<string, any>;\n    // 用于存储数据结构的模式\n    schema?: ObjectSchemaNode & Partial<RootAdditionalProps>;\n};\n\nexport interface VariableData {\n    old_variables: MvuData;\n    /**\n     * 输出变量，仅当实际产生了变量变更的场合，会产生 newVariables\n     */\n    new_variables?: MvuData;\n}\n\nexport const variable_events = {\n    SINGLE_VARIABLE_UPDATED: 'mag_variable_updated',\n    VARIABLE_UPDATE_ENDED: 'mag_variable_update_ended',\n    VARIABLE_UPDATE_STARTED: 'mag_variable_update_started',\n} as const;\nexport const exported_events = {\n    INVOKE_MVU_PROCESS: 'mag_invoke_mvu',\n    UPDATE_VARIABLE: 'mag_update_variable',\n} as const;\n\nexport type InternalData = {\n    display_data: Record<string, any>;\n    delta_data: Record<string, any>;\n};\n\nexport type ExtendedListenerType = {\n    [variable_events.SINGLE_VARIABLE_UPDATED]: (\n        stat_data: Record<string, any>,\n        path: string,\n        _oldValue: any,\n        _newValue: any\n    ) => void;\n    [variable_events.VARIABLE_UPDATE_STARTED]: (\n        variables: MvuData,\n        out_is_updated: boolean\n    ) => void;\n    [variable_events.VARIABLE_UPDATE_ENDED]: (variables: MvuData, out_is_updated: boolean) => void;\n    [exported_events.INVOKE_MVU_PROCESS]: (\n        message_content: string,\n        variable_info: VariableData\n    ) => void;\n    [exported_events.UPDATE_VARIABLE]: (\n        stat_data: Record<string, any>,\n        path: string,\n        newValue: any,\n        reason: string,\n        isRecursive: boolean\n    ) => void;\n};\n\nexport type InitVarType = StatData & RootAdditionalMetaProps;\n\nexport type DataCategory = 'stat' | 'display' | 'delta';\n\nexport function extractRecord(category: 'stat' | 'display' | 'delta', game_data: MvuData) {\n    let data: Record<string, any> | undefined = undefined;\n    switch (category) {\n        case 'stat':\n            data = game_data.stat_data;\n            break;\n        case 'display':\n            data = game_data.display_data!;\n            break;\n        case 'delta':\n            data = game_data.delta_data!;\n            break;\n    }\n    return data;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = __WEBPACK_EXTERNAL_MODULE_https_testingcf_jsdelivr_net_npm_mathjs_esm_aec644b1__;","import {\n    SchemaNode,\n    StatData,\n    isArraySchema,\n    isObjectSchema,\n    ObjectSchemaNode,\n    MvuData,\n    ArraySchemaNode,\n    TemplateType,\n    RootAdditionalProps,\n} from '@/variable_def';\n\n// 定义魔法字符串为常量，便于管理和引用\nexport const EXTENSIBLE_MARKER = '$__META_EXTENSIBLE__$';\n\n// 模式生成函数\n/**\n * 递归地为数据对象生成一个模式。\n * @param data - 要为其生成模式的数据对象 (stat_data)。\n * @param oldSchemaNode - (可选) 来自旧 Schema 的对应节点，用于继承元数据。\n * @param parentRecursiveExtensible - (可选) 父节点的 recursiveExtensible 状态，默认为 false。\n * @returns - 生成的模式对象。\n */\nexport function generateSchema(\n    data: any,\n    oldSchemaNode?: SchemaNode,\n    parentRecursiveExtensible: boolean = false\n): SchemaNode {\n    if (Array.isArray(data)) {\n        let isExtensible = false;\n        let isRecursiveExtensible = parentRecursiveExtensible;\n        let oldElementType: SchemaNode | undefined;\n        let template: TemplateType | undefined;\n\n        // 使用类型守卫检查 oldSchemaNode 是否为 ArraySchemaNode\n        if (oldSchemaNode) {\n            if (isArraySchema(oldSchemaNode)) {\n                isExtensible = oldSchemaNode.extensible === true;\n                isRecursiveExtensible =\n                    oldSchemaNode.recursiveExtensible === true || parentRecursiveExtensible;\n                oldElementType = oldSchemaNode.elementType;\n                template = oldSchemaNode.template;\n            } else {\n                console.error(\n                    `Type mismatch: expected array schema but got ${oldSchemaNode.type} at path`\n                );\n            }\n        }\n\n        // 检查是否有只包含 $meta 的元素\n        const metaElementIndex = data.findIndex(\n            item =>\n                _.isObject(item) &&\n                !_.isDate(item) &&\n                '$arrayMeta' in item &&\n                '$meta' in item &&\n                item['$arrayMeta'] === true\n        );\n\n        if (metaElementIndex !== -1) {\n            const metaElement = data[metaElementIndex] as { $meta: any };\n            // 从 $meta 中提取数组的元数据\n            if (metaElement.$meta.extensible !== undefined) {\n                isExtensible = metaElement.$meta.extensible;\n            }\n            if (metaElement.$meta.template !== undefined) {\n                template = metaElement.$meta.template;\n            }\n            // 从数组中移除这个元数据元素\n            data.splice(metaElementIndex, 1);\n            console.log(`Array metadata element found and processed.`);\n        }\n\n        // 检查并处理魔法字符串\n        const markerIndex = data.indexOf(EXTENSIBLE_MARKER);\n        if (markerIndex > -1) {\n            isExtensible = true;\n            // 从数组中移除标记，以免影响后续的类型推断\n            data.splice(markerIndex, 1);\n            console.log(`Extensible marker found and removed from an array.`);\n        }\n\n        const schema_node: ArraySchemaNode = {\n            type: 'array',\n            extensible: isExtensible || parentRecursiveExtensible,\n            recursiveExtensible: isRecursiveExtensible,\n            elementType:\n                data.length > 0\n                    ? generateSchema(data[0], oldElementType, isRecursiveExtensible)\n                    : { type: 'any' },\n        };\n\n        if (template !== undefined) {\n            schema_node.template = template;\n        }\n\n        return schema_node;\n    }\n    if (_.isObject(data) && !_.isDate(data)) {\n        const typedData = data as StatData; // 类型断言\n\n        // 使用类型守卫检查 oldSchemaNode 是否为 ObjectSchemaNode\n        let oldExtensible = false;\n        let oldRecursiveExtensible = parentRecursiveExtensible;\n        let oldProperties: ObjectSchemaNode['properties'] | undefined;\n\n        if (oldSchemaNode) {\n            if (isObjectSchema(oldSchemaNode)) {\n                oldExtensible = oldSchemaNode.extensible === true;\n                oldRecursiveExtensible =\n                    oldSchemaNode.recursiveExtensible === true || parentRecursiveExtensible;\n                oldProperties = oldSchemaNode.properties;\n            } else {\n                console.error(\n                    `Type mismatch: expected object schema but got ${oldSchemaNode.type} at path`\n                );\n            }\n        }\n\n        const schemaNode: ObjectSchemaNode = {\n            type: 'object',\n            properties: {},\n            // 默认不可扩展，但检查旧 schema、$meta.extensible 或 parentRecursiveExtensible\n            extensible:\n                oldExtensible ||\n                typedData.$meta?.extensible === true ||\n                typedData.$meta?.recursiveExtensible === true ||\n                parentRecursiveExtensible,\n            recursiveExtensible:\n                oldRecursiveExtensible || typedData.$meta?.recursiveExtensible === true,\n        };\n\n        // 处理 template\n        if (typedData.$meta?.template !== undefined) {\n            schemaNode.template = typedData.$meta.template;\n        } else if (oldSchemaNode && isObjectSchema(oldSchemaNode) && oldSchemaNode.template) {\n            schemaNode.template = oldSchemaNode.template;\n        }\n\n        // 暂存父节点的 $meta，以便在循环中使用\n        const parentMeta = typedData.$meta;\n\n        // 从 $meta 中读取信息后，将其从数据中移除，避免污染\n        if (typedData.$meta) {\n            delete typedData.$meta;\n        }\n\n        for (const key in data) {\n            const oldChildNode = oldProperties?.[key];\n            // 传递当前节点的 recursiveExtensible（如果存在）或父节点的 recursiveExtensible\n            // 但如果当前节点明确设置 extensible: false, 则停止递归扩展\n            const childRecursiveExtensible =\n                schemaNode.extensible !== false && schemaNode.recursiveExtensible;\n            const childSchema = generateSchema(\n                typedData[key],\n                oldChildNode,\n                childRecursiveExtensible\n            );\n\n            // 一个属性是否必需？\n\n            // 1. 默认值: 如果父节点可扩展，子节点默认为可选；否则为必需。\n            let isRequired = !schemaNode.extensible;\n\n            // 2. 覆盖规则: 检查父元数据中的 'required' 数组。\n            //    如果父节点的 $meta.required 是一个数组，并且当前 key 在这个数组里，\n            //    则无论默认值是什么，都强制覆盖为必需。\n            if (Array.isArray(parentMeta?.required) && parentMeta.required.includes(key)) {\n                isRequired = true;\n            }\n\n            // 3. 检查旧 schema 的设置，作为最后的参考\n            if (oldChildNode?.required === false) {\n                // 如果旧 schema 明确说这个是可选的，那么以这个为准\n                isRequired = false;\n            } else if (oldChildNode?.required === true) {\n                isRequired = true;\n            }\n\n            schemaNode.properties[key] = {\n                ...childSchema,\n                required: isRequired,\n            };\n        }\n        return schemaNode;\n    }\n    // 处理原始类型\n    const dataType = typeof data;\n    if (dataType === 'string' || dataType === 'number' || dataType === 'boolean') {\n        return { type: dataType };\n    }\n    // 对于其他类型（function, symbol, bigint, undefined 等），默认返回 'any'\n    return { type: 'any' };\n}\n\n/**\n * 辅助函数：为数据路径获取对应的 Schema 规则。\n * 能够处理数组索引，将其转换为 .elementType 来查询 Schema。\n * @param schema - 完整的 Schema 对象\n * @param path - 要查询的数据路径\n * @returns 对应路径的 Schema 节点，如果找不到则返回 null。\n */\nexport function getSchemaForPath(\n    schema: SchemaNode | null | undefined,\n    path: string\n): SchemaNode | null {\n    if (!path || !schema) {\n        return schema || null;\n    }\n    // 将 lodash 路径字符串转换为段数组，例如 'a.b[0].c' -> ['a', 'b', '0', 'c']\n    const pathSegments = _.toPath(path);\n    let currentSchema: SchemaNode | null = schema;\n\n    for (const segment of pathSegments) {\n        if (!currentSchema) return null;\n\n        // 如果 segment 是数字（数组索引），则移动到 elementType\n        if (/^\\d+$/.test(segment)) {\n            if (isArraySchema(currentSchema)) {\n                currentSchema = currentSchema.elementType;\n            } else {\n                return null; // 路径试图索引一个非数组或无 elementType 的 schema\n            }\n        } else if (isObjectSchema(currentSchema) && currentSchema.properties[segment]) {\n            // 否则，作为对象属性访问\n            const property = currentSchema.properties[segment];\n            currentSchema = property as SchemaNode;\n        } else {\n            return null; // 路径中的键在 schema 中不存在\n        }\n    }\n    return currentSchema;\n}\n\n/**\n * 调和函数：比较数据和旧 Schema，生成并应用一个与当前数据状态完全同步的新 Schema。\n * @param variables - 包含 stat_data 和旧 schema 的变量对象。\n */\nexport function reconcileAndApplySchema(variables: MvuData) {\n    console.log('Reconciling schema with current data state...');\n\n    // 1. 深拷贝数据，以防 generateSchema 修改原始数据（例如删除 $meta）\n    const currentDataClone = _.cloneDeep(variables.stat_data);\n\n    // 2. 使用改进后的 generateSchema 生成一个与当前数据完全匹配的新 Schema，\n    //    并在此过程中从旧 Schema 继承元数据。\n    const newSchema = generateSchema(currentDataClone, variables.schema);\n\n    // 3. 直接用新 Schema 替换旧 Schema\n    // stat_data 的根节点应该始终是对象，所以生成的 schema 也应该是 ObjectSchemaNode\n    if (!isObjectSchema(newSchema)) {\n        console.error(\n            'Generated schema is not an object schema, which is unexpected for stat_data root'\n        );\n        return;\n    }\n\n    // 保留 RootAdditionalProps\n    const newSchemaWithProps = newSchema as ObjectSchemaNode & RootAdditionalProps;\n    if (variables.schema?.strictTemplate !== undefined) {\n        newSchemaWithProps.strictTemplate = variables.schema.strictTemplate;\n    }\n    if (variables.schema?.strictSet !== undefined) {\n        newSchemaWithProps.strictSet = variables.schema.strictSet;\n    }\n    if (variables.schema?.concatTemplateArray !== undefined) {\n        newSchemaWithProps.concatTemplateArray = variables.schema.concatTemplateArray;\n    }\n    if (_.has(variables.stat_data, '$meta.strictTemplate'))\n        newSchemaWithProps.strictTemplate = variables.stat_data['$meta']?.strictTemplate as boolean;\n    if (_.has(variables.stat_data, '$meta.strictSet'))\n        newSchemaWithProps.strictSet = variables.stat_data['$meta']?.strictSet as boolean;\n    if (_.has(variables.stat_data, '$meta.concatTemplateArray'))\n        newSchemaWithProps.concatTemplateArray = variables.stat_data['$meta']\n            ?.concatTemplateArray as boolean;\n\n    variables.schema = newSchemaWithProps;\n\n    console.log('Schema reconciliation complete.');\n}\n\nfunction isMetaCarrier(value: unknown): value is Record<string, unknown> & { $meta?: unknown } {\n    return _.isObject(value) && !_.isDate(value);\n}\n\n/**\n * 递归清理数据中的元数据标记\n * - 从数组中移除 EXTENSIBLE_MARKER\n * - 从对象中删除 $meta 属性\n * @param data 需要清理的数据\n */\nexport function cleanUpMetadata(data: any): void {\n    // 如果是数组，移除魔法字符串和只包含 $meta 的元素，并递归\n    if (Array.isArray(data)) {\n        let i = data.length;\n        while (i--) {\n            if (data[i] === EXTENSIBLE_MARKER) {\n                data.splice(i, 1);\n            } else if (\n                _.isObject(data[i]) &&\n                !_.isDate(data[i]) &&\n                '$arrayMeta' in data[i] &&\n                '$meta' in data[i] &&\n                data[i]['$arrayMeta'] === true\n            ) {\n                // 移除只包含 $meta & $arrayMeta 的元素\n                data.splice(i, 1);\n            } else {\n                // 对数组中的其他元素（可能是对象或数组）进行递归清理\n                cleanUpMetadata(data[i]);\n            }\n        }\n    }\n    // 如果是对象，移除 $meta 并递归\n    else if (isMetaCarrier(data)) {\n        // 清除自身 $meta\n        delete data.$meta;\n\n        // 递归\n        for (const key in data) {\n            cleanUpMetadata(data[key]);\n        }\n    }\n}\n","export type LocalizedBooleanTrue = '是';\nexport type LocalizedBooleanFalse = '否';\n\n/**\n * 可以接受任意值，但是只有 LocalizedBooleanTrue 代表 true\n * 在 Migrate 过程中其他任何值都会退化为 LocalizedBooleanFalse\n */\nexport type StringBoolean = string | LocalizedBooleanTrue | LocalizedBooleanFalse;\n\nexport type MvuSettings = {\n    是否显示变量更新错误: StringBoolean;\n    构建信息: string;\n};\n\n//存储所有变量的默认值，需要设置默认值的时候可以 _.merge({}, DefaultSetting, 原始内容)\nconst DefaultSetting: MvuSettings = {\n    是否显示变量更新错误: '是',\n    构建信息: '未知',\n};\n\nconst variable_option = {\n    type: 'script',\n    script_id: typeof getScriptId === 'function' ? getScriptId() : 'default-script-id',\n} as const;\n\nexport function VerifySettings(settings: any): settings is MvuSettings {\n    // 检查settings是否是对象\n    if (!settings || typeof settings !== 'object') {\n        return false;\n    }\n\n    // 检查必需的字段是否存在\n    if (!('是否显示变量更新错误' in settings)) {\n        return false;\n    }\n\n    // 检查字段类型是否正确（StringBoolean应该是字符串类型）\n    if (typeof settings.是否显示变量更新错误 !== 'string') {\n        return false;\n    }\n\n    return true;\n}\n\n/**\n * 对所有StringBoolean类型的字段进行退化处理\n * 只有 '是' 代表 true，其他值都退化为 '否'\n */\nfunction FallbackStringBoolean(settings: Record<string, any>) {\n    // 定义MvuSettings中所有StringBoolean类型的字段\n    const stringBooleanFields: (keyof MvuSettings)[] = ['是否显示变量更新错误'];\n\n    for (const key of stringBooleanFields) {\n        if (key in settings) {\n            const value = settings[key];\n            // 如果不是字符串类型，或者不是'是'，都退化为'否'\n            if (typeof value !== 'string') {\n                settings[key] = '否';\n            } else if (value !== '是') {\n                settings[key] = '否';\n            }\n        }\n    }\n}\n\nfunction updateVersionInfo(settings: MvuSettings) {\n    try {\n        settings.构建信息 = `${__BUILD_DATE__ ?? 'Unknown'} (${__COMMIT_ID__ ?? 'Unknown'})`;\n    } catch (e) {\n        /* empty */\n    }\n}\n\n/**\n * 获取变量配置，并进行检查。\n * 补齐缺失的变量，将已有的变量进行退化。\n */\nexport async function GetSettings(): Promise<MvuSettings> {\n    const settings = getVariables(variable_option) || {};\n\n    // 如果verify失败或设置为空，使用默认值\n    if (!VerifySettings(settings)) {\n        // 使用lodash合并默认设置\n        const mergedSettings = _.merge({}, DefaultSetting, settings);\n\n        // 对StringBoolean类型进行退化处理\n        FallbackStringBoolean(mergedSettings);\n        updateVersionInfo(mergedSettings);\n\n        // 保存更新后的设置\n        await replaceVariables(mergedSettings, variable_option);\n        return mergedSettings;\n    }\n\n    // 即使verify通过，也要确保所有字段都存在并进行退化处理\n    const mergedSettings = _.merge({}, DefaultSetting, settings);\n\n    // 对StringBoolean类型进行退化处理\n    FallbackStringBoolean(mergedSettings);\n    updateVersionInfo(mergedSettings);\n\n    // 如果有任何变化，保存设置\n    if (!_.isEqual(settings, mergedSettings)) {\n        await replaceVariables(mergedSettings, variable_option);\n    }\n\n    return mergedSettings;\n}\n","import {\n    variable_events,\n    VariableData,\n    MvuData,\n    TemplateType,\n    assertVWD,\n    isArraySchema,\n    isObjectSchema,\n    isValueWithDescriptionStatData,\n} from '@/variable_def';\nimport * as math from 'mathjs';\n\nimport { getSchemaForPath, reconcileAndApplySchema } from '@/schema';\nimport { GetSettings } from '@/settings';\n\nexport function trimQuotesAndBackslashes(str: string): string {\n    if (!_.isString(str)) return str;\n    // Regular expression to match backslashes and quotes (including backticks) at the beginning and end\n    return str.replace(/^[\\\\\"'` ]*(.*?)[\\\\\"'` ]*$/, '$1');\n}\n\n/**\n * 应用模板到值上，值的属性优先级高于模板\n * @param value 要应用模板的值\n * @param template 模板 (TemplateType | undefined)\n * @param strict_array_cast 是否开启严格模式，开启后不允许 primitive type -> [primitive type] 的隐式转换\n * @param array_merge_concat 指明数组的 合并 行为是指 覆盖 还是 拼接，默认拼接。\n * @returns 合并后的值\n */\nexport function applyTemplate(\n    value: any,\n    template: TemplateType | undefined,\n    strict_array_cast: boolean = false,\n    array_merge_concat: boolean = true\n): any {\n    // 如果没有模板，直接返回原值\n    if (!template) {\n        return value;\n    }\n\n    // 检查类型是否匹配\n    const value_is_object = _.isObject(value) && !Array.isArray(value) && !_.isDate(value);\n    const value_is_array = Array.isArray(value);\n    const template_is_array = Array.isArray(template);\n\n    if (value_is_object && !template_is_array) {\n        // value 是对象，template 是 StatData（对象）\n        // 先应用模板，再应用值，确保值的优先级更高\n        return _.merge({}, template, value);\n    } else if (value_is_array && template_is_array) {\n        // 都是数组，进行合并\n        if (array_merge_concat) return _.concat(value, template);\n        return _.merge([], template, value);\n    } else if (\n        ((value_is_object || value_is_array) && template_is_array !== value_is_array) ||\n        (!value_is_object && !value_is_array && _.isObject(template) && !Array.isArray(template))\n    ) {\n        // 类型不匹配\n        console.error(\n            `Template type mismatch: template is ${template_is_array ? 'array' : 'object'}, but value is ${value_is_array ? 'array' : 'object'}. Skipping template merge.`\n        );\n        return value;\n    } else if (!value_is_object && !value_is_array && template_is_array) {\n        // 特殊情况：值是原始类型（字面量），模板是数组\n        // 当作 [value] 进行数组的合并\n        if (strict_array_cast)\n            //严格模式不提供 primitive type -> [primitive type] 的转换\n            return value;\n        if (array_merge_concat) return _.concat([value], template);\n        return _.merge([], template, [value]);\n    } else {\n        // 其他情况：值是原始类型，模板不是数组，不应用模板\n        return value;\n    }\n}\n\n// 一个更安全的、用于解析命令中值的辅助函数\n// 它会尝试将字符串解析为 JSON, 布尔值, null, 数字, 或数学表达式\nexport function parseCommandValue(valStr: string): any {\n    if (typeof valStr !== 'string') return valStr;\n    const trimmed = valStr.trim();\n\n    // 检查布尔值/null/undefined\n    if (trimmed === 'true') return true;\n    if (trimmed === 'false') return false;\n    if (trimmed === 'null') return null;\n    if (trimmed === 'undefined') return undefined;\n\n    try {\n        // 如果字符串能被 JSON.parse 解析，说明它是一个标准格式，直接返回解析结果\n        return JSON.parse(trimmed);\n    } catch (e) {\n        // Handle JavaScript array or object literals\n        if (\n            (trimmed.startsWith('{') && trimmed.endsWith('}')) ||\n            (trimmed.startsWith('[') && trimmed.endsWith(']'))\n        ) {\n            try {\n                // Safely evaluate literals using a function constructor\n                const result = new Function(`return ${trimmed};`)();\n                if (_.isObject(result) || Array.isArray(result)) {\n                    return result;\n                }\n            } catch (err) {\n                // 如果解析失败，说明它可能是一个未加引号的字符串或数学表达式，继续往下走\n            }\n        }\n    }\n\n    // 如果代码走到这里，说明 trimmed 是一个未加引号的字符串，例如：\n    // 'hello_world', '10 + 2', 'sqrt(16)'\n\n    try {\n        // 创建一个 scope 对象，将多种数学库/对象注入到 mathjs 的执行环境中，\n        // 以便统一处理不同风格的数学表达式。\n        const scope = {\n            // 支持 JavaScript 标准的 Math 对象 (e.g., Math.sqrt(), Math.PI)\n            Math: Math,\n            // 支持 Python 风格的 math 库用法 (e.g., math.sqrt(), math.pi)，\n            // 这在 LLM 生成的代码中很常见。\n            // 'math' 是我们导入的 mathjs 库本身。\n            math: math,\n        };\n        // 尝试使用 mathjs 进行数学求值\n        // math.evaluate 对于无法识别为表达式的纯字符串会抛出错误\n        const result = math.evaluate(trimmed, scope);\n        // 如果结果是 mathjs 的复数或矩阵对象，则将其转换为字符串表示形式\n        if (math.isComplex(result) || math.isMatrix(result)) {\n            return result.toString();\n        }\n        // 避免将单个单词的字符串（mathjs可能将其识别为符号）作为 undefined 返回\n        if (result === undefined && !/^[a-zA-Z_]+$/.test(trimmed)) {\n            return trimmed; // 如果是 undefined 但不是一个简单的符号名，则可能是解析错误\n        }\n        if (result !== undefined) {\n            // 使用 toPrecision 来处理浮点数精度造成的误差问题\n            return parseFloat(result.toPrecision(12));\n        }\n    } catch (err) {\n        // 如果 math.evaluate 失败，说明它不是一个有效的表达式，\n        // 那么它就是一个普通的未加引号的字符串。\n    }\n\n    // 实验性功能，暂不启用\n    // 尝试将字符串解析为日期对象，用于传入_.add直接以毫秒数更新时间，如 `_.add('当前时间', 10 * 60 * 1000);`\n    // 此检查用于识别日期字符串（例如 \"2024-01-01T12:00:00Z\"）\n    // `isNaN(Number(trimmed))`确保纯数字字符串（如 \"12345\"）不会被错误地解析为日期\n    /*\n    if (isNaN(Number(trimmed))) {\n        const potentialDate = new Date(trimQuotesAndBackslashes(trimmed));\n        if (!isNaN(potentialDate.getTime())) {\n            return potentialDate;\n        }\n    }\n    */\n\n    try {\n        // 尝试 YAML.parse\n        return YAML.parse(trimmed);\n    } catch (e) {\n        /* empty */\n    }\n\n    // 最终，返回这个去除了首尾引号的字符串\n    return trimQuotesAndBackslashes(valStr);\n}\n\n/**\n * Type definition for CommandNames representing a set of valid command strings.\n *\n * This type is used to define a finite and specific set of command string values\n * that may be used in operations or functions requiring predefined command names.\n *\n * The allowed command names are:\n * - 'set': Represents a command to set a value.\n * - 'insert': Alias of 'assign'\n * - 'assign': Represents a command to assign a value or reference.\n * - 'remove': Represents a command to remove an item or data.\n * - 'add': Represents a command to add an item or data.\n */\ntype CommandNames = 'set' | 'insert' | 'assign' | 'remove' | 'unset' | 'delete' | 'add';\n\n/**\n * 从大字符串中提取所有 .set(${path}, ${new_value});//${reason} 格式的模式\n * 并解析出每个匹配项的路径、新值和原因部分\n */\n// 接口定义：用于统一不同命令的结构\n// 新增：Command 接口，比 SetCommand 更通用\ninterface Command {\n    command: CommandNames;\n    fullMatch: string;\n    args: string[];\n    reason: string;\n}\n\n/**\n * 从输入文本中提取所有 _.set() 调用\n *\n * 问题背景：\n * 原本使用正则表达式 /_\\.set\\(([\\s\\S]*?)\\);/ 来匹配，但这种非贪婪匹配会在遇到\n * 嵌套的 ); 时提前结束。例如：\n * _.set('path', [\"text with _.set('inner',null);//comment\"], []);\n * 会在 \"comment\") 处错误地结束匹配\n *\n * 解决方案：\n * 使用状态机方法，通过计数括号配对来准确找到 _.set() 调用的结束位置\n */\n// 将 extractSetCommands 扩展为 extractCommands 以支持多种命令\nexport function extractCommands(inputText: string): Command[] {\n    const results: Command[] = [];\n    let i = 0;\n\n    while (i < inputText.length) {\n        // 循环处理整个输入文本，直到找不到更多命令\n        // 使用正则匹配 _.set(、_.assign(、_.remove( 或 _.add(，重构后支持多种命令\n        const setMatch = inputText\n            .substring(i)\n            .match(/_\\.(set|insert|assign|remove|unset|delete|add)\\(/);\n        if (!setMatch || setMatch.index === undefined) {\n            // 没有找到匹配的命令，退出循环，防止无限循环\n            break;\n        }\n\n        // 提取命令类型（set、assign、remove 或 add），并计算命令的起始位置\n        const commandType = setMatch[1] as CommandNames;\n        const setStart = i + setMatch.index;\n        // 计算开括号位置，用于后续提取参数\n        const openParen = setStart + setMatch[0].length;\n\n        // 使用 findMatchingCloseParen 查找匹配的闭括号，解决原正则匹配在嵌套结构（如 _.set('path', ['inner);'])）中提前结束的问题\n        const closeParen = findMatchingCloseParen(inputText, openParen);\n        if (closeParen === -1) {\n            // 找不到闭括号，说明命令格式错误\n            // 跳过此无效命令，并从开括号后继续搜索，以防无限循环\n            i = openParen; // 从开括号后继续搜索\n            continue; // 继续 while 循环，寻找下一个命令\n        }\n\n        // 检查闭括号后是否紧跟分号，确保命令语法完整，防止误解析字符串中的类似结构\n        let endPos = closeParen + 1;\n        if (endPos >= inputText.length || inputText[endPos] !== ';') {\n            // 没有分号，命令无效，跳到闭括号后继续搜索，避免误解析\n            i = closeParen + 1;\n            continue;\n        }\n        endPos++; // 包含分号，更新命令结束位置\n\n        // 提取可能的注释（// 开头），用于记录命令的 reason\n        let comment = '';\n        const potentialComment = inputText.substring(endPos).match(/^\\s*\\/\\/(.*)/);\n        if (potentialComment) {\n            // 提取注释内容并去除首尾空格，更新结束位置\n            comment = potentialComment[1].trim();\n            endPos += potentialComment[0].length;\n        }\n\n        // 提取完整命令字符串，用于返回结果中的 fullMatch 字段，便于追踪原始内容\n        const fullMatch = inputText.substring(setStart, endPos);\n        // 提取参数字符串，位于开括号和闭括号之间\n        const paramsString = inputText.substring(openParen, closeParen);\n        // 使用 parseParameters 解析参数，支持嵌套结构（如数组、对象）\n        const params = parseParameters(paramsString);\n\n        // 验证命令有效性，根据命令类型检查参数数量，防止无效命令进入结果\n        let isValid = false;\n        if (commandType === 'set' && params.length >= 2)\n            isValid = true; // _.set 至少需要路径和值\n        else if (commandType === 'assign' && params.length >= 2)\n            isValid = true; // _.assign 支持两种参数格式\n        else if (commandType === 'insert' && params.length >= 2)\n            isValid = true; // _.insert 支持两种参数格式\n        else if (commandType === 'remove' && params.length >= 1)\n            isValid = true; // _.remove 至少需要路径\n        else if (commandType === 'unset' && params.length >= 1)\n            isValid = true; // _.unset 至少需要路径\n        else if (commandType === 'delete' && params.length >= 1)\n            isValid = true; // _.delete 至少需要路径\n        else if (commandType === 'add' && /*params.length === 1 || */ params.length === 2)\n            isValid = true; // _.add 需要1个或2个参数\n\n        if (isValid) {\n            // 命令有效，添加到结果列表，包含命令类型、完整匹配、参数和注释\n            results.push({ command: commandType, fullMatch, args: params, reason: comment });\n        }\n\n        // 更新搜索索引到命令末尾，继续查找下一个命令\n        i = endPos;\n    }\n\n    // 返回所有解析出的有效命令\n    return results;\n}\n\n/**\n * 辅助函数：找到匹配的闭括号\n *\n * 算法说明：\n * 1. 使用括号计数器，遇到 ( 加1，遇到 ) 减1\n * 2. 当计数器归零时，找到了匹配的闭括号\n * 3. 重要：忽略引号内的括号，避免字符串内容干扰匹配\n *\n * @param str 要搜索的字符串\n * @param startPos 开始括号的位置\n * @returns 匹配的闭括号位置，如果找不到返回 -1\n */\nfunction findMatchingCloseParen(str: string, startPos: number): number {\n    let parenCount = 1; // 从1开始，因为已经有一个开括号\n    let inQuote = false;\n    let quoteChar = '';\n\n    for (let i = startPos; i < str.length; i++) {\n        const char = str[i];\n        const prevChar = i > 0 ? str[i - 1] : '';\n\n        // 处理引号状态\n        // 支持三种引号：双引号、单引号和反引号（模板字符串）\n        // 注意：需要检查前一个字符不是反斜杠，以正确处理转义的引号\n        if ((char === '\"' || char === \"'\" || char === '`') && prevChar !== '\\\\') {\n            if (!inQuote) {\n                inQuote = true;\n                quoteChar = char;\n            } else if (char === quoteChar) {\n                inQuote = false;\n            }\n        }\n\n        // 只在不在引号内时计算括号\n        // 这确保了像 \"text with )\" 这样的字符串不会影响括号匹配\n        if (!inQuote) {\n            if (char === '(') {\n                parenCount++;\n            } else if (char === ')') {\n                parenCount--;\n                if (parenCount === 0) {\n                    return i;\n                }\n            }\n        }\n    }\n\n    return -1; // 没有找到匹配的闭括号\n}\n\n// 解析参数字符串，处理嵌套结构\n// 增加了对圆括号的层级计数。\nexport function parseParameters(paramsString: string): string[] {\n    const params: string[] = [];\n    let currentParam = '';\n    let inQuote = false;\n    let quoteChar = '';\n    let bracketCount = 0;\n    let braceCount = 0;\n    let parenCount = 0;\n\n    for (let i = 0; i < paramsString.length; i++) {\n        const char = paramsString[i];\n\n        // 处理引号（包括反引号）\n        if (\n            (char === '\"' || char === \"'\" || char === '`') &&\n            (i === 0 || paramsString[i - 1] !== '\\\\')\n        ) {\n            if (!inQuote) {\n                inQuote = true;\n                quoteChar = char;\n            } else if (char === quoteChar) {\n                inQuote = false;\n            }\n        }\n\n        if (!inQuote) {\n            // 处理圆括号 (函数调用、数学运算等)\n            if (char === '(') parenCount++;\n            if (char === ')') parenCount--;\n\n            // 处理方括号 (数组)\n            if (char === '[') bracketCount++;\n            if (char === ']') bracketCount--;\n\n            // 处理花括号 (对象)\n            if (char === '{') braceCount++;\n            if (char === '}') braceCount--;\n        }\n        // 处理参数分隔符\n        // 现在只有当所有括号都匹配闭合时，逗号才被视为分隔符\n        if (\n            char === ',' &&\n            !inQuote &&\n            parenCount === 0 &&\n            bracketCount === 0 &&\n            braceCount === 0\n        ) {\n            params.push(currentParam.trim());\n            currentParam = '';\n            continue;\n        }\n\n        currentParam += char;\n    }\n\n    // 添加最后一个参数\n    if (currentParam.trim()) {\n        params.push(currentParam.trim());\n    }\n\n    return params;\n}\n\nexport async function getLastValidVariable(message_id: number): Promise<MvuData> {\n    return (structuredClone(\n        _(SillyTavern.chat)\n            .slice(0, message_id + 1)\n            .map(chat_message => _.get(chat_message, ['variables', chat_message.swipe_id ?? 0]))\n            .findLast(variables => _.has(variables, 'stat_data'))\n    ) ?? getVariables()) as MvuData;\n}\n\nfunction pathFix(path: string): string {\n    const segments = [];\n    let currentSegment = '';\n    let inQuotes = false;\n    let quoteChar = '';\n\n    for (let i = 0; i < path.length; i++) {\n        const char = path[i];\n\n        // Handle quotes\n        if ((char === '\"' || char === \"'\") && (i === 0 || path[i - 1] !== '\\\\')) {\n            if (!inQuotes) {\n                inQuotes = true;\n                quoteChar = char;\n            } else if (char === quoteChar) {\n                inQuotes = false;\n            } else {\n                currentSegment += char;\n            }\n        } else if (char === '.' && !inQuotes) {\n            segments.push(currentSegment);\n            currentSegment = '';\n        } else {\n            currentSegment += char;\n        }\n    }\n\n    if (currentSegment) {\n        segments.push(currentSegment);\n    }\n\n    return segments.join('.');\n}\n\n/**\n * MVU 风格的变量更新操作，同时会更新 display_data/delta_data\n * @param stat_data 当前的变量状态，来源应当是 mag_variable_updated 回调中提供的 stat_data。其他来源则不会修改 display_data 等。\n * @param path 要更改的变量路径\n * @param new_value 新值\n * @param reason 修改原因（可选，默认为空）\n * @param is_recursive 此次修改是否允许触发 mag_variable_updated 回调（默认不允许）\n */\nexport async function updateVariable(\n    stat_data: Record<string, any>,\n    path: string,\n    new_value: any,\n    reason: string = '',\n    is_recursive: boolean = false\n): Promise<boolean> {\n    const display_data = stat_data.$internal?.display_data;\n    const delta_data = stat_data.$internal?.delta_data;\n    if (_.has(stat_data, path)) {\n        const currentValue = _.get(stat_data, path);\n        if (Array.isArray(currentValue) && currentValue.length === 2) {\n            //VWD 处理\n            const oldValue = _.cloneDeep(currentValue[0]);\n            currentValue[0] = new_value;\n            _.set(stat_data, path, currentValue);\n            const reason_str = reason ? `(${reason})` : '';\n            const display_str = `${trimQuotesAndBackslashes(JSON.stringify(oldValue))}->${trimQuotesAndBackslashes(JSON.stringify(new_value))} ${reason_str}`;\n            if (display_data) _.set(display_data, path, display_str);\n            if (delta_data) _.set(delta_data, path, display_str);\n            console.info(\n                `Set '${path}' to '${trimQuotesAndBackslashes(JSON.stringify(new_value))}' ${reason_str}`\n            );\n            if (is_recursive)\n                await eventEmit(\n                    variable_events.SINGLE_VARIABLE_UPDATED,\n                    stat_data,\n                    path,\n                    oldValue,\n                    new_value\n                );\n            return true;\n        } else {\n            const oldValue = _.cloneDeep(currentValue);\n            _.set(stat_data, path, new_value);\n            const reason_str = reason ? `(${reason})` : '';\n            const stringNewValue = trimQuotesAndBackslashes(JSON.stringify(new_value));\n            const display_str = `${trimQuotesAndBackslashes(JSON.stringify(oldValue))}->${stringNewValue} ${reason_str}`;\n            if (display_data) _.set(display_data, path, display_str);\n            if (delta_data) _.set(delta_data, path, display_str);\n            console.info(`Set '${path}' to '${stringNewValue}' ${reason_str}`);\n            if (is_recursive)\n                await eventEmit(\n                    variable_events.SINGLE_VARIABLE_UPDATED,\n                    stat_data,\n                    path,\n                    oldValue,\n                    new_value\n                );\n            return true;\n        }\n    }\n    return false;\n}\n\ntype ErrorInfo = {\n    error_last: string;\n    error_command: Command;\n};\n\n// 重构 updateVariables 以处理更多命令\nexport async function updateVariables(\n    current_message_content: string,\n    variables: MvuData\n): Promise<boolean> {\n    const out_is_modifed = false;\n    // 深拷贝变量对象，生成状态快照，用于记录显示数据\n    const out_status: MvuData = _.cloneDeep(variables);\n    // 初始化增量状态对象，记录变化详情\n    const delta_status: Partial<MvuData> = { stat_data: {} };\n\n    // 重构新增：统一处理宏替换，确保命令中的宏（如 ${variable}）被替换，提升一致性\n    const processed_message_content = substitudeMacros(current_message_content);\n\n    // 使用重构后的 extractCommands 提取所有命令\n    const commands = extractCommands(processed_message_content);\n    // 触发变量更新开始事件，通知外部系统\n    const settings = await GetSettings();\n    variables.stat_data.$internal = {\n        display_data: out_status.stat_data,\n        delta_data: delta_status.stat_data || {},\n    };\n    await eventEmit(variable_events.VARIABLE_UPDATE_STARTED, variables, out_is_modifed);\n    let variable_modified = false;\n\n    let error_info: ErrorInfo | undefined;\n    let current_command: Command | undefined;\n    const outError = function (message: string) {\n        console.warn(message);\n        error_info = {\n            error_last: message,\n            error_command: current_command!,\n        };\n    };\n\n    const schema = variables.schema; // 获取 schema，可能为 undefined\n    const strict_template = schema?.strictTemplate ?? false;\n    const concat_template_array = schema?.concatTemplateArray ?? true;\n    const strict_set = schema?.strictSet ?? false;\n\n    for (const command of commands) {\n        // 遍历所有命令，逐一处理\n        // 修正路径格式，去除首尾引号和反斜杠，确保路径有效\n        const path = pathFix(trimQuotesAndBackslashes(command.args[0]));\n        // 生成原因字符串，用于日志和显示\n        const reason_str = command.reason ? `(${command.reason})` : '';\n        let display_str = ''; // 初始化显示字符串，记录操作详情\n        current_command = command;\n\n        switch (\n            command.command // 根据命令类型执行不同操作\n        ) {\n            case 'set': {\n                // _.has 检查，确保路径存在\n                if (!_.has(variables.stat_data, path)) {\n                    outError(\n                        `Path '${path}' does not exist in stat_data, skipping set command ${reason_str}`\n                    );\n                    continue;\n                }\n\n                // 获取路径上的旧值，可能为 undefined（路径不存在）\n                let oldValue = _.get(variables.stat_data, path);\n                // 支持两种格式：_.set(path, newValue) 或 _.set(path, oldValue, newValue)\n                const newValueStr = command.args.length >= 3 ? command.args[2] : command.args[1];\n                // 解析新值，支持字符串、数字、布尔值、JSON 对象等\n                let newValue = parseCommandValue(newValueStr);\n\n                // 在写入前，将 Date 对象序列化为 ISO 字符串\n                if (newValue instanceof Date) {\n                    newValue = newValue.toISOString();\n                }\n                let isPathVWD = false;\n\n                if (\n                    !strict_set &&\n                    Array.isArray(oldValue) &&\n                    oldValue.length === 2 &&\n                    typeof oldValue[1] === 'string' &&\n                    !Array.isArray(oldValue[0])\n                ) {\n                    // 处理 ValueWithDescription<T> 类型，更新数组第一个元素\n                    // 仅当旧值为数字且新值不为 null 时，才强制转换为数字\n                    // 这允许将数字字段设置为 null (例如角色死亡后好感度变为 null)\n                    const oldValueCopy = _.cloneDeep(oldValue[0]);\n                    oldValue[0] =\n                        typeof oldValue[0] === 'number' && newValue !== null\n                            ? Number(newValue)\n                            : newValue;\n                    oldValue = oldValueCopy;\n                    isPathVWD = true;\n                } else if (typeof oldValue === 'number' && newValue !== null) {\n                    _.set(variables.stat_data, path, Number(newValue));\n                } else {\n                    // 其他情况直接设置新值，支持任意类型\n                    _.set(variables.stat_data, path, newValue);\n                }\n\n                // 获取最终设置的新值，用于日志和事件\n                let finalNewValue = _.get(variables.stat_data, path);\n\n                assertVWD(isPathVWD, finalNewValue);\n\n                if (isPathVWD) {\n                    finalNewValue = finalNewValue[0];\n                }\n\n                // 检查是否为 ValueWithDescription 类型，以优化显示\n                const isStrict = !strict_set;\n\n                if (\n                    isStrict &&\n                    isValueWithDescriptionStatData(oldValue) &&\n                    Array.isArray(finalNewValue)\n                ) {\n                    // 如果是 ValueWithDescription，只显示值的变化\n                    display_str = `${trimQuotesAndBackslashes(JSON.stringify(oldValue[0]))}->${trimQuotesAndBackslashes(JSON.stringify(finalNewValue[0]))} ${reason_str}`;\n                } else {\n                    // 否则，按常规显示\n                    display_str = `${trimQuotesAndBackslashes(JSON.stringify(oldValue))}->${trimQuotesAndBackslashes(JSON.stringify(finalNewValue))} ${reason_str}`;\n                }\n\n                variable_modified = true; // 标记变量已修改\n                // 记录操作日志，便于调试\n                console.info(`Set '${path}' to '${JSON.stringify(finalNewValue)}' ${reason_str}`);\n\n                // 触发单变量更新事件，通知外部系统\n                await eventEmit(\n                    variable_events.SINGLE_VARIABLE_UPDATED,\n                    variables.stat_data,\n                    path,\n                    oldValue,\n                    finalNewValue\n                );\n                break;\n            }\n\n            case 'insert':\n            case 'assign': {\n                // 检查目标路径是否指向一个集合（数组或对象）\n                // 如果路径已存在且其值为原始类型（字符串、数字等），则跳过此命令，以防止结构污染\n                const targetPath = path;\n                // 统一获取目标值和目标Schema，优雅地处理根路径\n                const existingValue =\n                    targetPath === ''\n                        ? variables.stat_data\n                        : _.get(variables.stat_data, targetPath);\n                const targetSchema = getSchemaForPath(schema, targetPath);\n\n                // 验证1：目标是否为原始类型？如果是，则无法插入。\n                if (\n                    existingValue !== null &&\n                    !Array.isArray(existingValue) &&\n                    !_.isObject(existingValue)\n                ) {\n                    outError(\n                        `Cannot assign into path '${targetPath}' because it holds a primitive value (${typeof existingValue}). Operation skipped. ${reason_str}`\n                    );\n                    continue;\n                }\n\n                // 验证2：Schema 规则\n                if (targetSchema) {\n                    if (targetSchema.type === 'object' && targetSchema.extensible === false) {\n                        if (command.args.length === 2) {\n                            // 合并\n                            outError(\n                                `SCHEMA VIOLATION: Cannot merge data into non-extensible object at path '${targetPath}'. ${reason_str}`\n                            );\n                            continue;\n                        }\n                        if (command.args.length >= 3) {\n                            // 插入键\n                            const newKey = String(parseCommandValue(command.args[1]));\n                            if (!_.has(targetSchema.properties, newKey)) {\n                                outError(\n                                    `SCHEMA VIOLATION: Cannot assign new key '${newKey}' into non-extensible object at path '${targetPath}'. ${reason_str}`\n                                );\n                                continue;\n                            }\n                        }\n                    } else if (\n                        targetSchema.type === 'array' &&\n                        (targetSchema.extensible === false || targetSchema.extensible === undefined)\n                    ) {\n                        outError(\n                            `SCHEMA VIOLATION: Cannot assign elements into non-extensible array at path '${targetPath}'. ${reason_str}`\n                        );\n                        continue;\n                    }\n                } else if (\n                    // 增加 targetPath !== '' 条件，防止对根路径进行父路径检查\n                    targetPath !== '' &&\n                    !_.get(variables.stat_data, _.toPath(targetPath).slice(0, -1).join('.'))\n                ) {\n                    // 验证3：如果要插入到新路径，确保其父路径存在且可扩展\n                    outError(\n                        `Cannot assign into non-existent path '${targetPath}' without an extensible parent. ${reason_str}`\n                    );\n                    continue;\n                }\n                // --- 所有验证通过，现在可以安全执行 ---\n\n                // 深拷贝旧值，防止直接修改影响后续比较\n                const oldValue = _.cloneDeep(_.get(variables.stat_data, path));\n                let successful = false; // 标记插入是否成功\n\n                if (command.args.length === 2) {\n                    // _.assign('path.to.array', value)\n                    // 解析插入值，支持复杂类型\n                    let valueToAssign = parseCommandValue(command.args[1]);\n\n                    // 在写入前，将 Date 对象（或数组中的Date）序列化\n                    if (valueToAssign instanceof Date) {\n                        valueToAssign = valueToAssign.toISOString();\n                    } else if (Array.isArray(valueToAssign)) {\n                        valueToAssign = valueToAssign.map(item =>\n                            item instanceof Date ? item.toISOString() : item\n                        );\n                    }\n\n                    // 获取目标集合，可能为数组或对象\n                    let collection =\n                        targetPath === '' ? variables.stat_data : _.get(variables.stat_data, path);\n\n                    // 如果目标不存在，初始化为空数组或对象\n                    if (!Array.isArray(collection) && !_.isObject(collection)) {\n                        collection = Array.isArray(valueToAssign) ? [] : {};\n                        _.set(variables.stat_data, path, collection);\n                    }\n\n                    if (Array.isArray(collection)) {\n                        // 目标是数组，追加元素\n                        // 检查是否有模板并应用\n                        const template =\n                            targetSchema && isArraySchema(targetSchema)\n                                ? targetSchema.template\n                                : undefined;\n                        valueToAssign = applyTemplate(\n                            valueToAssign,\n                            template,\n                            strict_template,\n                            concat_template_array\n                        );\n                        collection.push(valueToAssign);\n                        display_str = `ASSIGNED ${JSON.stringify(valueToAssign)} into array '${path}' ${reason_str}`;\n                        successful = true;\n                    } else if (_.isObject(collection)) {\n                        // 目标是对象，合并属性\n                        // 注意：对象合并时不应用模板，因为无法明确确定增加的元素\n                        // 模板只在明确添加单个新属性时应用（如使用三参数的 assign）\n                        if (_.isObject(valueToAssign) && !Array.isArray(valueToAssign)) {\n                            _.merge(collection, valueToAssign);\n                            display_str = `MERGED object ${JSON.stringify(valueToAssign)} into object '${path}' ${reason_str}`;\n                            successful = true;\n                        } else {\n                            // 不支持将数组或非对象合并到对象，记录错误\n                            outError(\n                                `Cannot merge ${Array.isArray(valueToAssign) ? 'array' : 'non-object'} into object at '${path}'`\n                            );\n                            continue;\n                        }\n                    }\n                } else if (command.args.length >= 3) {\n                    // _.assign('path', key/index, value)\n                    // 解析插入值和键/索引\n                    let valueToAssign = parseCommandValue(command.args[2]);\n                    const keyOrIndex = parseCommandValue(command.args[1]);\n\n                    // 在写入前，将 Date 对象（或数组中的Date）序列化\n                    if (valueToAssign instanceof Date) {\n                        valueToAssign = valueToAssign.toISOString();\n                    } else if (Array.isArray(valueToAssign)) {\n                        valueToAssign = valueToAssign.map(item =>\n                            item instanceof Date ? item.toISOString() : item\n                        );\n                    }\n\n                    let collection =\n                        targetPath === '' ? variables.stat_data : _.get(variables.stat_data, path);\n\n                    // 获取模板\n                    const template =\n                        targetSchema &&\n                        (isArraySchema(targetSchema) || isObjectSchema(targetSchema))\n                            ? targetSchema.template\n                            : undefined;\n\n                    if (Array.isArray(collection) && typeof keyOrIndex === 'number') {\n                        // 目标是数组且索引是数字，插入到指定位置\n                        valueToAssign = applyTemplate(\n                            valueToAssign,\n                            template,\n                            strict_template,\n                            concat_template_array\n                        );\n                        collection.splice(keyOrIndex, 0, valueToAssign);\n                        display_str = `ASSIGNED ${JSON.stringify(valueToAssign)} into '${path}' at index ${keyOrIndex} ${reason_str}`;\n                        successful = true;\n                    } else if (_.isObject(collection)) {\n                        // 目标是对象，设置指定键\n                        // _.set(collection, String(keyOrIndex), valueToAssign);\n                        // 对单个属性值应用模板\n                        valueToAssign = applyTemplate(\n                            valueToAssign,\n                            template,\n                            strict_template,\n                            concat_template_array\n                        );\n                        (collection as Record<string, unknown>)[String(keyOrIndex)] = valueToAssign;\n                        display_str = `ASSIGNED key '${keyOrIndex}' with value ${JSON.stringify(valueToAssign)} into object '${path}' ${reason_str}`;\n                        successful = true;\n                    } else {\n                        // 目标不存在，创建新对象并插入\n                        collection = {};\n                        _.set(variables.stat_data, path, collection);\n                        /*\n                        _.set(\n                            collection as Record<string, unknown>,\n                            String(keyOrIndex),\n                            valueToAssign\n                        );\n                        */\n                        // 对新属性值应用模板\n                        valueToAssign = applyTemplate(\n                            valueToAssign,\n                            template,\n                            strict_template,\n                            concat_template_array\n                        );\n                        (collection as Record<string, unknown>)[String(keyOrIndex)] = valueToAssign;\n                        display_str = `CREATED object at '${path}' and ASSIGNED key '${keyOrIndex}' ${reason_str}`;\n                        successful = true;\n                    }\n                }\n\n                if (successful) {\n                    // 插入成功，获取新值并触发事件\n                    const newValue = _.get(variables.stat_data, path);\n                    variable_modified = true;\n                    console.info(display_str);\n                    await eventEmit(\n                        variable_events.SINGLE_VARIABLE_UPDATED,\n                        variables.stat_data,\n                        path,\n                        oldValue,\n                        newValue\n                    );\n                } else {\n                    // 插入失败，记录错误并继续处理下一命令\n                    outError(`Invalid arguments for _.assign on path '${path}'`);\n                    continue;\n                }\n                break;\n            }\n\n            case 'unset':\n            case 'delete':\n            case 'remove': {\n                // 验证路径存在，防止无效删除\n                if (!_.has(variables.stat_data, path)) {\n                    outError(`undefined Path: ${path} in _.remove command`);\n                    continue;\n                }\n\n                // --- 模式校验开始 ---\n                let containerPath = path;\n                let keyOrIndexToRemove: string | number | undefined;\n\n                if (command.args.length > 1) {\n                    // _.remove('path', key_or_index)\n                    keyOrIndexToRemove = parseCommandValue(command.args[1]);\n                    // 如果 key 是字符串，需要去除可能存在的引号\n                    if (typeof keyOrIndexToRemove === 'string') {\n                        keyOrIndexToRemove = trimQuotesAndBackslashes(keyOrIndexToRemove);\n                    }\n                } else {\n                    // _.remove('path.to.key[index]')\n                    const pathParts = _.toPath(path);\n                    const lastPart = pathParts.pop();\n                    if (lastPart) {\n                        keyOrIndexToRemove = /^\\d+$/.test(lastPart) ? Number(lastPart) : lastPart;\n                        containerPath = pathParts.join('.');\n                    }\n                }\n\n                if (keyOrIndexToRemove === undefined) {\n                    outError(\n                        `Could not determine target for deletion for command on path '${path}' ${reason_str}`\n                    );\n                    continue;\n                }\n                // 只有当容器路径不是根路径（即不为空）时，才检查其是否存在\n                if (containerPath !== '' && !_.has(variables.stat_data, containerPath)) {\n                    outError(\n                        `Cannot remove from non-existent path '${containerPath}'. ${reason_str}`\n                    );\n                    continue;\n                }\n\n                const containerSchema = getSchemaForPath(schema, containerPath);\n\n                if (containerSchema) {\n                    if (containerSchema.type === 'array') {\n                        if (containerSchema.extensible !== true) {\n                            outError(\n                                `SCHEMA VIOLATION: Cannot remove element from non-extensible array at path '${containerPath}'. ${reason_str}`\n                            );\n                            continue;\n                        }\n                    } else if (containerSchema.type === 'object') {\n                        const keyString = String(keyOrIndexToRemove);\n                        if (\n                            _.has(containerSchema.properties, keyString) &&\n                            containerSchema.properties[keyString].required === true\n                        ) {\n                            outError(\n                                `SCHEMA VIOLATION: Cannot remove required key '${keyString}' from path '${containerPath}'. ${reason_str}`\n                            );\n                            continue;\n                        }\n                    }\n                }\n\n                // --- 所有验证通过，现在可以安全执行 ---\n\n                // 解析删除目标，可能是值或索引\n                const targetToRemove =\n                    command.args.length > 1 ? parseCommandValue(command.args[1]) : undefined;\n                let itemRemoved = false; // 标记是否删除成功\n\n                if (targetToRemove === undefined) {\n                    // _.remove('path.to.key')\n                    // 删除整个路径\n                    const oldValue = _.get(variables.stat_data, path);\n                    _.unset(variables.stat_data, path);\n                    display_str = `REMOVED path '${path}' ${reason_str}`;\n                    itemRemoved = true;\n                    await eventEmit(\n                        variable_events.SINGLE_VARIABLE_UPDATED,\n                        variables.stat_data,\n                        path,\n                        oldValue,\n                        undefined\n                    );\n                } else {\n                    // _.remove('path.to.array', value_or_index)\n                    const collection = _.get(variables.stat_data, path);\n\n                    // 当从一个集合中删除元素时，必须确保目标路径确实是一个集合\n                    // 如果目标是原始值（例如字符串），则无法执行删除操作\n                    if (!Array.isArray(collection) && !_.isObject(collection)) {\n                        outError(\n                            `Cannot remove from path '${path}' because it is not an array or object. Skipping command. ${reason_str}`\n                        );\n                        continue;\n                    }\n\n                    if (Array.isArray(collection)) {\n                        // 目标是数组，删除指定元素\n                        const originalArray = _.cloneDeep(collection);\n                        let indexToRemove = -1;\n                        if (typeof targetToRemove === 'number') {\n                            indexToRemove = targetToRemove;\n                        } else {\n                            indexToRemove = collection.findIndex(item =>\n                                _.isEqual(item, targetToRemove)\n                            );\n                        }\n\n                        if (indexToRemove >= 0 && indexToRemove < collection.length) {\n                            collection.splice(indexToRemove, 1);\n                            itemRemoved = true;\n                            display_str = `REMOVED item from '${path}' ${reason_str}`;\n                            await eventEmit(\n                                variable_events.SINGLE_VARIABLE_UPDATED,\n                                variables.stat_data,\n                                path,\n                                originalArray,\n                                collection\n                            );\n                        }\n                    } else if (_.isObject(collection)) {\n                        if (typeof targetToRemove === 'number') {\n                            // 目标是对象，按索引删除键\n                            const keys = Object.keys(collection);\n                            const index = targetToRemove;\n                            if (index >= 0 && index < keys.length) {\n                                const keyToRemove = keys[index];\n                                _.unset(collection, keyToRemove);\n                                itemRemoved = true;\n                                display_str = `REMOVED ${index + 1}th entry ('${keyToRemove}') from object '${path}' ${reason_str}`;\n                            }\n                        } else {\n                            // 目标是对象，按键名删除\n                            const keyToRemove = String(targetToRemove);\n                            if (_.has(collection, keyToRemove)) {\n                                // _.unset(collection, keyToRemove);\n                                delete (collection as Record<string, unknown>)[keyToRemove];\n                                itemRemoved = true;\n                                display_str = `REMOVED key '${keyToRemove}' from object '${path}' ${reason_str}`;\n                            }\n                        }\n                    }\n                }\n\n                if (itemRemoved) {\n                    // 删除成功，更新状态并记录日志\n                    variable_modified = true;\n                    console.info(display_str);\n                } else {\n                    // 删除失败，记录警告并继续\n                    outError(`Failed to execute remove on '${path}'`);\n                    continue;\n                }\n                break;\n            }\n\n            case 'add': {\n                // 验证路径存在\n                if (!_.has(variables.stat_data, path)) {\n                    outError(\n                        `Path '${path}' does not exist in stat_data, skipping add command ${reason_str}`\n                    );\n                    continue;\n                }\n                // 获取当前值\n                const initialValue = _.cloneDeep(_.get(variables.stat_data, path));\n                const oldValue = _.get(variables.stat_data, path);\n                let valueToAdd = oldValue;\n                const isVWD =\n                    isValueWithDescriptionStatData(oldValue) && typeof oldValue[0] !== 'object';\n\n                if (isVWD) {\n                    assertVWD(isVWD, oldValue);\n                    valueToAdd = oldValue[0]; // 对 ValueWithDescription 类型，操作其第一个元素\n                }\n                // console.warn(valueToAdd);\n\n                // 尝试将当前值解析为 Date 对象，无论其原始类型是 Date 还是字符串\n                let potentialDate: Date | null = null;\n                if (valueToAdd instanceof Date) {\n                    potentialDate = valueToAdd;\n                } else if (typeof valueToAdd === 'string') {\n                    const parsedDate = new Date(valueToAdd);\n                    // 确保它是一个有效的日期，并且不是一个可以被 `new Date` 解析的纯数字字符串\n                    if (!isNaN(parsedDate.getTime()) && isNaN(Number(valueToAdd))) {\n                        potentialDate = parsedDate;\n                    }\n                }\n\n                if (command.args.length === 2) {\n                    // 双参数：调整数值或日期\n                    const delta = parseCommandValue(command.args[1]);\n\n                    // 处理 Date 类型\n                    if (potentialDate) {\n                        if (typeof delta !== 'number') {\n                            outError(\n                                `Delta '${command.args[1]}' for Date operation is not a number, skipping add command ${reason_str}`\n                            );\n                            continue;\n                        }\n                        // delta 是毫秒数，更新时间\n                        const newDate = new Date(potentialDate.getTime() + delta);\n                        // 总是将更新后的 Date 对象转换为 ISO 字符串再存回去\n                        const finalValueToSet = newDate.toISOString();\n\n                        if (isVWD) {\n                            assertVWD(isVWD, oldValue);\n                            oldValue[0] = finalValueToSet;\n                            _.set(variables.stat_data, path, oldValue);\n                        } else {\n                            _.set(variables.stat_data, path, finalValueToSet);\n                        }\n\n                        const finalNewValue = _.get(variables.stat_data, path);\n                        if (isVWD) {\n                            display_str = `${JSON.stringify((initialValue as any[])[0])}->${JSON.stringify((finalNewValue as any[])[0])} ${reason_str}`;\n                        } else {\n                            display_str = `${JSON.stringify(initialValue)}->${JSON.stringify(finalNewValue)} ${reason_str}`;\n                        }\n                        variable_modified = true;\n                        console.info(\n                            `ADDED date '${path}' from '${potentialDate.toISOString()}' to '${newDate.toISOString()}' by delta '${delta}'ms ${reason_str}`\n                        );\n                        await eventEmit(\n                            variable_events.SINGLE_VARIABLE_UPDATED,\n                            variables.stat_data,\n                            path,\n                            initialValue,\n                            finalNewValue\n                        );\n                    } else if (typeof valueToAdd === 'number') {\n                        // 原有的处理 number 类型的逻辑\n                        if (typeof delta !== 'number') {\n                            outError(\n                                `Delta '${command.args[1]}' is not a number, skipping add command ${reason_str}`\n                            );\n                            continue;\n                        }\n                        let newValue = valueToAdd + delta;\n                        newValue = parseFloat(newValue.toPrecision(12)); // 避免浮点数精度误差\n                        if (isVWD) {\n                            oldValue[0] = newValue; // Update the first element\n                            _.set(variables.stat_data, path, oldValue);\n                        } else {\n                            _.set(variables.stat_data, path, newValue);\n                        }\n                        const finalNewValue = _.get(variables.stat_data, path);\n                        if (isVWD) {\n                            display_str = `${JSON.stringify((initialValue as any[])[0])}->${JSON.stringify((finalNewValue as any[])[0])} ${reason_str}`;\n                        } else {\n                            display_str = `${JSON.stringify(initialValue)}->${JSON.stringify(finalNewValue)} ${reason_str}`;\n                        }\n                        variable_modified = true;\n                        console.info(\n                            `ADDED number '${path}' from '${valueToAdd}' to '${newValue}' by delta '${delta}' ${reason_str}`\n                        );\n                        await eventEmit(\n                            variable_events.SINGLE_VARIABLE_UPDATED,\n                            variables.stat_data,\n                            path,\n                            initialValue,\n                            finalNewValue\n                        );\n                    } else {\n                        // 如果值不是可识别的类型（日期、数字），则跳过\n                        outError(\n                            `Path '${path}' value is not a date or number; skipping add command ${reason_str}`\n                        );\n                        continue;\n                    }\n                } else {\n                    outError(\n                        `Invalid number of arguments for _.add on path '${path}' ${reason_str}`\n                    );\n                    continue;\n                }\n                break;\n            }\n        }\n\n        if (display_str) {\n            // 更新状态和增量数据，记录操作详情\n            _.set(out_status.stat_data, path, display_str);\n            _.set(delta_status.stat_data!, path, display_str);\n        }\n    }\n    // 更新变量的显示和增量数据\n    variables.display_data = out_status.stat_data;\n    variables.delta_data = delta_status.stat_data!;\n    // 触发变量更新结束事件\n    await eventEmit(variable_events.VARIABLE_UPDATE_ENDED, variables, out_is_modifed);\n    //在结束事件中也可能设置变量\n    delete variables.stat_data.$internal;\n\n    // 在所有命令执行完毕后，如果数据有任何变动，则执行一次 Schema 调和\n    if (variable_modified) {\n        reconcileAndApplySchema(variables);\n    }\n    if (error_info && settings.是否显示变量更新错误 === '是') {\n        const base_command: string = error_info.error_command.fullMatch;\n        if (typeof toastr !== 'undefined')\n            toastr.warning(\n                `最近错误: ${error_info.error_last}`,\n                `发生变量更新错误，可能需要重Roll:${base_command}`,\n                { timeOut: 6000 }\n            );\n    }\n\n    // 返回是否修改了变量\n    return variable_modified || out_is_modifed;\n}\n\n// Rate limiting for handleVariablesInMessage - execute at most once every 3 seconds\nlet lastExecutionTime = 0;\nconst RATE_LIMIT_INTERVAL = 3000; // 3 seconds in milliseconds\n\nexport async function handleVariablesInMessage(message_id: number) {\n    // Skip rate limiting in Jest test environment\n    const isJestEnvironment =\n        // @ts-ignore\n        typeof jest !== 'undefined' ||\n        // @ts-ignore\n        (typeof process !== 'undefined' && process.env?.NODE_ENV === 'test');\n\n    if (!isJestEnvironment) {\n        const now = Date.now();\n        if (now - lastExecutionTime < RATE_LIMIT_INTERVAL) {\n            console.info(\n                `Rate limit applied: handleVariablesInMessage skipped for message ${message_id}`\n            );\n            toastr.warning('避免同时调用 MESSAGE_RECEIVED 多次', 'gemini轮询兼容', {\n                timeOut: 1000,\n            });\n            return;\n        }\n        lastExecutionTime = now;\n    }\n\n    const chat_message = getChatMessages(message_id).at(-1);\n    if (!chat_message) {\n        return;\n    }\n\n    let message_content = chat_message.message;\n\n    if (message_content.length < 5)\n        //MESSAGE_RECEIVED会递交一个 \"...\" 的消息\n        return;\n    const request_message_id = message_id === 0 ? 0 : message_id - 1;\n    const variables = await getLastValidVariable(request_message_id);\n    if (!_.has(variables, 'stat_data')) {\n        console.error(`cannot found stat_data for ${request_message_id}`);\n        return;\n    }\n\n    const has_variable_modified = await updateVariables(message_content, variables);\n    if (has_variable_modified) {\n        const chat_variables = getVariables({ type: 'chat' });\n        // _.merge 可能使变量无法被正常移除，因此使用赋值的方式\n        chat_variables.stat_data = variables.stat_data;\n        chat_variables.display_data = variables.display_data;\n        chat_variables.delta_data = variables.delta_data;\n        chat_variables.schema = variables.schema;\n        chat_variables.initialized_lorebooks = variables.initialized_lorebooks;\n        await replaceVariables(chat_variables, { type: 'chat' });\n    }\n    await insertOrAssignVariables(\n        {\n            stat_data: variables.stat_data,\n            display_data: variables.display_data,\n            delta_data: variables.delta_data,\n            schema: variables.schema,\n            initialized_lorebooks: variables.initialized_lorebooks,\n        },\n        { type: 'message', message_id: message_id }\n    );\n\n    if (chat_message.role !== 'user') {\n        if (!message_content.includes('<StatusPlaceHolderImpl/>')) {\n            message_content += '\\n\\n<StatusPlaceHolderImpl/>';\n        }\n        await setChatMessages(\n            [\n                {\n                    message_id: message_id,\n                    message: message_content,\n                },\n            ],\n            {\n                refresh: 'affected',\n            }\n        );\n    }\n}\n\nexport async function handleVariablesInCallback(\n    message_content: string,\n    in_out_variable_info: VariableData\n) {\n    if (in_out_variable_info.old_variables === undefined) {\n        return;\n    }\n    in_out_variable_info.new_variables = _.cloneDeep(in_out_variable_info.old_variables);\n    const variables = in_out_variable_info.new_variables;\n\n    const modified = await updateVariables(message_content, variables);\n    //如果没有修改，则不产生 newVariable\n    if (!modified) delete in_out_variable_info.new_variables;\n    return;\n}\n","/**\n * 递归更新描述字段\n *\n * 示例数据结构：\n * initData: {\n *   \"属性\": {\n *     \"value\": 100,\n *     \"description\": \"这是初始描述\"  // 条件 4(a)\n *   },\n *   \"生命值\": [100, \"初始生命值\"],  // 条件 4(b): ValueWithDescription<number>\n *   \"技能\": [{\n *     \"name\": \"攻击\",\n *     \"damage\": [50, \"基础伤害\"],  // 嵌套的 ValueWithDescription\n *     \"description\": \"普通攻击\"\n *   }],\n *   \"装备\": {\n *     \"武器\": [\"剑\", \"初始武器\"],  // ValueWithDescription<string>\n *     \"属性加成\": {\n *       \"攻击力\": [10, \"武器攻击力加成\"]\n *     }\n *   }\n * }\n */\nexport function updateDescriptions(\n    _init_path: string,\n    init_data: any,\n    msg_data: any,\n    target_data: any\n) {\n    _.forEach(init_data, (value, key) => {\n        const current_path = key; //init_path ? `${init_path}.${key}` : key;\n\n        if (_.isArray(value)) {\n            // 检查是否为 ValueWithDescription<T> 类型 (长度为2，第二个元素是字符串)\n            if (value.length === 2 && _.isString(value[1])) {\n                // 条件 4(b): 满足 ValueWithDescription<T> 定义\n                if (_.isArray(_.get(msg_data, current_path))) {\n                    const msgValue = _.get(msg_data, current_path);\n                    if (msgValue.length === 2) {\n                        // 更新描述(第二个元素)\n                        _.set(target_data, `${current_path}[1]`, value[1]);\n\n                        // 如果第一个元素是对象或数组，需要递归处理\n                        if (_.isObject(value[0]) && !_.isArray(value[0])) {\n                            // 处理对象\n                            const targetObj = _.get(target_data, `${key}[0]`);\n\n                            // 如果对象包含description属性，需要特殊处理\n                            if (\n                                _.has(value[0], 'description') &&\n                                _.isString(value[0].description)\n                            ) {\n                                if (_.has(msgValue[0], 'description')) {\n                                    _.set(\n                                        target_data,\n                                        `${current_path}[0].description`,\n                                        value[0].description\n                                    );\n                                }\n                            }\n\n                            // 递归处理对象的其他属性\n                            updateDescriptions(\n                                `${current_path}[0]`,\n                                value[0],\n                                msgValue[0],\n                                targetObj\n                            );\n                        } else if (_.isArray(value[0])) {\n                            // 处理数组\n                            updateDescriptions(\n                                `${current_path}[0]`,\n                                value[0],\n                                msgValue[0],\n                                target_data[0]\n                            );\n                        }\n                    }\n                }\n            } else if (_.isArray(_.get(msg_data, current_path))) {\n                // 普通数组，递归处理每个元素\n                const msg_array = _.get(msg_data, current_path);\n                value.forEach((item, index) => {\n                    if (index < msg_array.length) {\n                        if (_.isObject(item)) {\n                            const current_target = _.get(target_data, `${current_path}[${index}]`);\n                            // 如果对象包含description属性，需要特殊处理\n                            if (_.has(item, 'description') && _.isString(item.description)) {\n                                if (_.has(msg_array[index], 'description')) {\n                                    _.set(current_target, `description`, item.description);\n                                }\n                            }\n\n                            updateDescriptions(\n                                `${current_path}[${index}]`,\n                                value[index],\n                                msg_array[index],\n                                current_target\n                            );\n                        }\n                    }\n                });\n            }\n        } else if (_.isObject(value)) {\n            // 处理对象\n            if (_.has(value, 'description') && _.isString(value.description)) {\n                // 条件 4(a): 对象包含 description 字段且为字符串\n                //msg_data 等已经在递归时跟着进入了更深的层次，不需要 currentPath前缀\n                const description_path = `${key}.description`;\n                if (_.has(msg_data, description_path)) {\n                    _.set(target_data, description_path, value.description);\n                }\n            }\n\n            // 继续递归处理对象的其他属性\n            if (_.has(msg_data, key) && _.isObject(msg_data[key])) {\n                updateDescriptions(current_path, value, msg_data[key], target_data[key]);\n            }\n        }\n    });\n}\n","// 整体游戏数据类型\nimport { getLastValidVariable, updateVariables } from '@/function';\nimport { MvuData, isObjectSchema, RootAdditionalProps, SchemaNode } from '@/variable_def';\nimport { cleanUpMetadata, EXTENSIBLE_MARKER, generateSchema } from '@/schema';\nimport JSON5 from 'json5';\nimport TOML from 'toml';\n\ntype LorebookEntry = {\n    content: string;\n    comment?: string;\n};\n\nexport async function initCheck() {\n    let last_msg: ChatMessageSwiped;\n    let variables: MvuData & Record<string, any>;\n\n    try {\n        const result = await getLastMessageVariables();\n        last_msg = result.message;\n        variables =\n            (await getLastValidVariable(result.message.message_id)) ?? createEmptyGameData();\n    } catch (e) {\n        console.error('不存在任何一条消息，退出');\n        return;\n    }\n\n    // 确保变量结构完整\n    if (variables === undefined) {\n        variables = createEmptyGameData();\n    }\n    if (!_.has(variables, 'initialized_lorebooks')) {\n        variables.initialized_lorebooks = {};\n    }\n    if (Array.isArray(variables.initialized_lorebooks)) {\n        console.warn(\n            'Old \"initialized_lorebooks\" array format detected. Migrating to the new object format.'\n        );\n        const oldArray = variables.initialized_lorebooks as string[];\n        const newObject: Record<string, any[]> = {};\n        for (const lorebookName of oldArray) {\n            newObject[lorebookName] = []; // 按照新格式，值为一个空数组\n        }\n        variables.initialized_lorebooks = newObject;\n    }\n    if (!variables.stat_data) {\n        variables.stat_data = {};\n    }\n    if (!variables.schema) {\n        variables.schema = { extensible: false, properties: {}, type: 'object' };\n    }\n\n    // 加载 InitVar 数据\n    const is_updated = await loadInitVarData(variables);\n\n    // --- 一次性清理所有魔法字符串 ---\n    if (is_updated) {\n        // 递归遍历整个 stat_data，移除所有魔法字符串\n        const cleanData = (data: any) => {\n            if (Array.isArray(data)) {\n                // 使用 filter 创建一个不含标记的新数组\n                const cleanedArray = data.filter(item => item !== EXTENSIBLE_MARKER);\n                // 递归清理数组内的对象或数组\n                cleanedArray.forEach(cleanData);\n                return cleanedArray;\n            }\n            if (_.isObject(data)) {\n                const newObj: Record<string, any> = {};\n                const typedData = data as Record<string, any>; // 类型断言\n                for (const key in data) {\n                    // 递归清理子节点，并将结果赋给新对象\n                    newObj[key] = cleanData(typedData[key]);\n                }\n                return newObj;\n            }\n            return data;\n        };\n        // 在生成 Schema 之前，先清理一遍 stat_data\n        // 这里需要先生成 Schema，再清理数据\n        // 所以还是得用克隆\n    }\n\n    // 在所有 lorebook 初始化完成后，生成最终的模式\n    if (is_updated || !variables.schema || _.isEmpty(variables.schema)) {\n        // 1. 克隆数据用于 Schema 生成\n        const dataForSchema = _.cloneDeep(variables.stat_data);\n        // 2. generateSchema 会读取并移除克隆体中的标记，生成正确的 schema\n        const generated_schema: SchemaNode & RootAdditionalProps = generateSchema(dataForSchema);\n\n        // 使用类型守卫确保生成的 schema 是 ObjectSchemaNode\n        if (isObjectSchema(generated_schema)) {\n            if (_.has(variables.stat_data, '$meta.strictTemplate'))\n                generated_schema.strictTemplate = variables.stat_data['$meta']\n                    ?.strictTemplate as boolean;\n            if (_.has(variables.stat_data, '$meta.concatTemplateArray'))\n                generated_schema.concatTemplateArray = variables.stat_data['$meta']\n                    ?.concatTemplateArray as boolean;\n            if (_.has(variables.stat_data, '$meta.strictSet'))\n                generated_schema.strictSet = variables.stat_data['$meta']?.strictSet as boolean;\n            variables.schema = generated_schema;\n        } else {\n            console.error(\n                'Generated schema is not an object schema, which is unexpected for stat_data root'\n            );\n        }\n\n        // 3. 现在，清理真实的 stat_data，让它在后续操作中保持干净\n        cleanUpMetadata(variables.stat_data);\n    }\n\n    if (!is_updated) {\n        return;\n    }\n\n    console.info(`Init chat variables.`);\n    await insertOrAssignVariables(variables);\n\n    // 更新所有 swipes\n    for (let i = 0; i < last_msg.swipes.length; i++) {\n        const current_swipe_data = _.cloneDeep(variables);\n        // 此处调用的是新版 updateVariables，它将支持更多命令\n        // 不再需要手动调用 substitudeMacros，updateVariables 会处理\n        await updateVariables(last_msg.swipes[i], current_swipe_data);\n        //新版本这个接口给deprecated了，但是新版本的接口不好用，先这样\n        //@ts-ignore\n        await setChatMessage({ data: current_swipe_data }, last_msg.message_id, {\n            refresh: 'none',\n            swipe_id: i,\n        });\n    }\n    try {\n        // 输出构建信息\n        toastr.info(\n            `有新的世界书初始化变量被加载，当前使用世界书: ${YAML.stringify(variables.initialized_lorebooks)}`,\n            '变量初始化成功'\n        );\n    } catch (_e) {\n        /* empty */\n    }\n\n    // 更新 lorebook 设置\n    await updateLorebookSettings();\n}\n\n/**\n * 获取所有启用的 lorebook 列表\n */\nexport async function getEnabledLorebookList(): Promise<string[]> {\n    const lorebook_settings = await getLorebookSettings();\n    const enabled_lorebook_list = [...lorebook_settings.selected_global_lorebooks];\n    const char_lorebook = await getCurrentCharPrimaryLorebook();\n    if (char_lorebook !== null) {\n        enabled_lorebook_list.push(char_lorebook);\n    }\n    return enabled_lorebook_list;\n}\n\n/**\n * 从 lorebook 中加载所有 InitVar 数据并合并到提供的 GameData 中\n */\nexport async function loadInitVarData(\n    mvu_data: MvuData,\n    lorebook_list?: string[]\n): Promise<boolean> {\n    const enabled_lorebook_list = lorebook_list || (await getEnabledLorebookList());\n    let is_updated = false;\n\n    // 确保 initialized_lorebooks 是对象格式\n    if (!mvu_data.initialized_lorebooks || Array.isArray(mvu_data.initialized_lorebooks)) {\n        mvu_data.initialized_lorebooks = {};\n    }\n\n    for (const current_lorebook of enabled_lorebook_list) {\n        // 适配 beta 分支的对象结构\n        if (_.has(mvu_data.initialized_lorebooks, current_lorebook)) continue;\n        mvu_data.initialized_lorebooks[current_lorebook] = [];\n        const init_entries = (await getLorebookEntries(current_lorebook)) as LorebookEntry[];\n\n        for (const entry of init_entries) {\n            if (entry.comment?.toLowerCase().includes('[initvar]')) {\n                const content = substitudeMacros(entry.content);\n                let parsedData: any = null;\n                let parseError: Error | null = null;\n\n                // Try YAML first (which also handles JSON)\n                try {\n                    parsedData = YAML.parse(content);\n                } catch (e) {\n                    // Try JSON5\n                    try {\n                        parsedData = JSON5.parse(content);\n                    } catch (e2) {\n                        // Try TOML\n                        try {\n                            parsedData = TOML.parse(content);\n                        } catch (e3) {\n                            parseError = new Error(\n                                `Failed to parse content as YAML/JSON, JSON5, or TOML: ${e3}`\n                            );\n                        }\n                    }\n                }\n\n                if (parseError) {\n                    console.error(\n                        `Failed to parse lorebook entry[${entry.comment}]: ${parseError}`\n                    );\n                    // @ts-ignore\n                    toastr.error(parseError.message, 'Failed to parse lorebook entry', {\n                        timeOut: 5000,\n                    });\n                    throw parseError;\n                }\n\n                if (parsedData) {\n                    mvu_data.stat_data = _.merge(mvu_data.stat_data, parsedData);\n                }\n            }\n        }\n        is_updated = true;\n    }\n\n    return is_updated;\n}\n\n/**\n * 创建一个新的空 GameData 对象\n */\nexport function createEmptyGameData(): MvuData {\n    return {\n        display_data: {},\n        initialized_lorebooks: {}, // 适配 beta 分支的对象结构\n        stat_data: {},\n        delta_data: {},\n        schema: {\n            type: 'object',\n            properties: {},\n        }, // beta 分支新增的 schema 字段\n    };\n}\n\n/**\n * 获取最后一条消息的变量数据\n */\nexport async function getLastMessageVariables(): Promise<{\n    message: ChatMessageSwiped;\n    variables: MvuData | undefined;\n}> {\n    let last_chat_msg: ChatMessageSwiped[] = [];\n    try {\n        last_chat_msg = (await getChatMessages(-2, {\n            role: 'assistant',\n            include_swipes: true,\n        })) as ChatMessageSwiped[];\n    } catch (e) {\n        // 在第一行时，必定发生异常。\n    }\n\n    if (!last_chat_msg || last_chat_msg.length <= 0) {\n        const first_msg = await getChatMessages(0, {\n            include_swipes: true,\n        });\n        if (first_msg && first_msg.length > 0) {\n            last_chat_msg = first_msg;\n        } else {\n            throw new Error('不存在任何一条消息');\n        }\n    }\n\n    const last_msg = last_chat_msg[0];\n    const variables = last_msg.swipes_data[last_msg.swipe_id] as MvuData & Record<string, any>;\n\n    return { message: last_msg, variables };\n}\n\n/**\n * 更新 lorebook 设置为推荐配置\n */\nexport async function updateLorebookSettings(): Promise<void> {\n    /*Ref:https://github.com/lolo-desu/lolocard/blob/master/src/%E6%97%A5%E8%AE%B0%E7%BB%9C%E7%BB%9C/%E8%84%9A%E6%9C%AC/%E8%B0%83%E6%95%B4%E4%B8%96%E7%95%8C%E4%B9%A6%E5%85%A8%E5%B1%80%E8%AE%BE%E7%BD%AE.ts\n     */\n    const dst_setting: Partial<LorebookSettings> = {\n        scan_depth: 2,\n        context_percentage: 100,\n        budget_cap: 0,\n        min_activations: 0,\n        max_depth: 0,\n        max_recursion_steps: 0,\n\n        insertion_strategy: 'character_first',\n\n        include_names: false,\n        recursive: true,\n        case_sensitive: false,\n        match_whole_words: false,\n        use_group_scoring: false,\n        overflow_alert: false,\n    };\n    const settings = getLorebookSettings();\n    if (!_.isEqual(_.merge({}, settings, dst_setting), settings)) {\n        setLorebookSettings(dst_setting);\n    }\n}\n\n//window.initCheck = initCheck;\n","import { getLastValidVariable, handleVariablesInMessage } from '@/function';\nimport { updateDescriptions } from '@/update_descriptions';\nimport { createEmptyGameData, loadInitVarData } from '@/variable_init';\nimport { cleanUpMetadata, reconcileAndApplySchema } from '@/schema';\nimport { MvuData } from '@/variable_def';\n\nconst buttons = ['重新处理变量', '重新读取初始变量', '清除旧楼层变量'];\n\n// Rate limiting for button callbacks - execute at most once every 3 seconds\nlet lastButtonExecutionTime = 0;\nconst BUTTON_RATE_LIMIT_INTERVAL = 3000; // 3 seconds in milliseconds\n\nasync function reloadInit() {\n    // Skip rate limiting in Jest test environment\n    const isJestEnvironment =\n        // @ts-ignore\n        typeof jest !== 'undefined' ||\n        // @ts-ignore\n        (typeof process !== 'undefined' && process.env?.NODE_ENV === 'test');\n\n    if (!isJestEnvironment) {\n        const now = Date.now();\n        if (now - lastButtonExecutionTime < BUTTON_RATE_LIMIT_INTERVAL) {\n            console.info('Rate limit applied: 重新处理变量 button skipped');\n            toastr.warning('避免重复点击', '防止连点', { timeOut: 1000 });\n            return;\n        }\n        lastButtonExecutionTime = now;\n    }\n\n    // 1. 创建一个新的空 GameData 并加载 InitVar 数据\n    const latest_init_data = createEmptyGameData();\n\n    try {\n        const hasInitData = await loadInitVarData(latest_init_data);\n        if (!hasInitData) {\n            console.error('没有找到 InitVar 数据');\n            toastr.error('没有找到 InitVar 数据', '', { timeOut: 3000 });\n            return;\n        }\n    } catch (e) {\n        console.error('加载 InitVar 数据失败:', e);\n        return;\n    }\n    await reconcileAndApplySchema(latest_init_data);\n\n    cleanUpMetadata(latest_init_data.stat_data);\n\n    // 2. 从最新楼层获取最新变量\n    const message_id = getLastMessageId();\n    if (message_id < 0) {\n        console.error('没有找到消息');\n        toastr.error('没有找到消息', '', { timeOut: 3000 });\n        return;\n    }\n\n    const latest_msg_data = await getLastValidVariable(message_id);\n\n    if (!_.has(latest_msg_data, 'stat_data')) {\n        console.error('最新消息中没有找到 stat_data');\n        toastr.error('最新消息中没有 stat_data', '', { timeOut: 3000 });\n        return;\n    }\n\n    // 3. 产生新变量，以 latest_init_data 为基础，合并入 latest_msg_data 的内容\n    //此处 latest_init_data 内不存在复杂类型，因此可以采用 structuredClone\n    const merged_data: Record<string, any> = { stat_data: undefined, schema: undefined };\n    merged_data.stat_data = _.merge({}, latest_init_data.stat_data, latest_msg_data.stat_data);\n    merged_data.schema = _.merge({}, latest_msg_data.schema, latest_init_data.schema);\n    merged_data.initialized_lorebooks = _.merge(\n        {},\n        latest_init_data.initialized_lorebooks,\n        latest_msg_data.initialized_lorebooks\n    );\n    merged_data.display_data = structuredClone(merged_data.stat_data);\n    merged_data.delta_data = latest_msg_data.delta_data;\n\n    // 4-5. 遍历并更新描述字段\n    updateDescriptions(\n        '',\n        latest_init_data.stat_data,\n        latest_msg_data.stat_data,\n        merged_data.stat_data\n    );\n\n    //应用\n    await reconcileAndApplySchema(merged_data as MvuData);\n\n    cleanUpMetadata(merged_data.stat_data);\n\n    // 6. 更新变量到最新消息\n    await replaceVariables(merged_data, { type: 'message', message_id: message_id });\n\n    await replaceVariables(merged_data, { type: 'chat' });\n\n    console.info('InitVar更新完成');\n    toastr.success('InitVar描述已更新', '', { timeOut: 3000 });\n}\n\nfunction addButtons() {\n    const current_buttons = getScriptButtons(getScriptId());\n    const current_button_names = current_buttons.map(b => b.name);\n    for (const button of buttons.filter(b => !current_button_names.includes(b))) {\n        current_buttons.push({ name: button, visible: false });\n    }\n    replaceScriptButtons(getScriptId(), current_buttons);\n}\n\nexport function registerButtons() {\n    addButtons();\n\n    eventOnButton('重新处理变量', async function () {\n        // Skip rate limiting in Jest test environment\n        const isJestEnvironment =\n            // @ts-ignore\n            typeof jest !== 'undefined' ||\n            // @ts-ignore\n            (typeof process !== 'undefined' && process.env?.NODE_ENV === 'test');\n\n        if (!isJestEnvironment) {\n            const now = Date.now();\n            if (now - lastButtonExecutionTime < BUTTON_RATE_LIMIT_INTERVAL) {\n                console.info('Rate limit applied: 重新处理变量 button skipped');\n                toastr.warning('避免重复点击', '防止连点', { timeOut: 1000 });\n                return;\n            }\n            lastButtonExecutionTime = now;\n        }\n\n        const last_msg = getLastMessageId();\n        if (last_msg < 1) return;\n        if (SillyTavern.chat.length === 0) return;\n        await deleteVariable('stat_data', { type: 'message', message_id: last_msg });\n        await deleteVariable('delta_data', { type: 'message', message_id: last_msg });\n        await deleteVariable('display_data', { type: 'message', message_id: last_msg });\n        await deleteVariable('schema', { type: 'message', message_id: last_msg });\n        //重新处理变量\n        await handleVariablesInMessage(getLastMessageId());\n    });\n\n    eventOnButton('重新读取初始变量', reloadInit);\n\n    eventOnButton('清除旧楼层变量', async function () {\n        const result = (await SillyTavern.callGenericPopup(\n            '<h4>清除旧楼层变量信息以减小聊天文件大小避免手机崩溃</h4>请填写要保留变量信息的楼层数 (如 10 为保留最后 10 层)<br><strong>注意: 你将不能正常回退游玩到没保留变量信息的楼层</strong>',\n            SillyTavern.POPUP_TYPE.INPUT,\n            '10'\n        )) as string | undefined;\n        if (!result) {\n            return;\n        }\n        const depth = parseInt(result);\n        if (isNaN(depth)) {\n            toastr.error(`请输入有效的楼层数, 你输入的是 '${result}'`, '清理旧楼层变量失败');\n            return;\n        }\n        SillyTavern.chat.slice(0, -depth).forEach(chat_message => {\n            if (chat_message.variables === undefined) return;\n            chat_message.variables.forEach(variable => {\n                _.unset(variable, `stat_data`);\n                _.unset(variable, `display_data`);\n                _.unset(variable, `delta_data`);\n                _.unset(variable, `schema`);\n            });\n        });\n        SillyTavern.saveChat().then(() =>\n            toastr.success(`已清理旧变量, 保留了最后 ${depth} 层的变量`, '清理旧楼层变量成功')\n        );\n    });\n}\n","import { handleVariablesInCallback, updateVariable } from '@/function';\nimport {\n    extractRecord,\n    isValueWithDescription,\n    MvuData,\n    variable_events,\n    VariableData,\n} from '@/variable_def';\nimport { loadInitVarData } from '@/variable_init';\n\nfunction createMVU() {\n    const mvu = {\n        /**\n         * 变量事件常量集合\n         * 包含三个核心事件，用于监听和响应变量系统的不同更新阶段\n         *\n         * @property {string} SINGLE_VARIABLE_UPDATED - 'mag_variable_updated'\n         * 单个变量更新时触发的事件\n         * - 事件值: 'mag_variable_updated'\n         * - 回调签名: (stat_data: Record<string, any>, path: string, oldValue: any, newValue: any) => void\n         *   - stat_data: 完整的状态数据对象\n         *   - path: 被更新的变量路径（如 'player.health' 或 'items[0].name'）\n         *   - oldValue: 更新前的值\n         *   - newValue: 更新后的新值\n         * - 触发条件: 当通过 setMvuVariable / _.set 语句更新一个变量之后， 会触发这个事件\n         * - 典型用途:\n         *   - 实现变量间的联动逻辑（如等级提升时自动增加属性）\n         *   - 如果某个变量不符合更新条件，则拒绝这次更新。\n         *\n         * @property {string} VARIABLE_UPDATE_STARTED - 'mag_variable_update_started'\n         * 批量变量更新开始时触发的事件\n         * - 事件值: 'mag_variable_update_started'\n         * - 回调签名: (variables: MvuData, out_is_updated: boolean) => void\n         *   - variables: 包含 stat_data、display_data、delta_data 的完整数据对象\n         *   - out_is_updated: 弃用\n         * - 触发时机: parseMessage 或 LLM消息回复结束 开始解析命令之前\n         * - 典型用途:\n         *   - 保存更新前的状态快照\n         *   - 初始化批处理所需的临时数据结构\n         *\n         * @property {string} VARIABLE_UPDATE_ENDED - 'mag_variable_update_ended'\n         * 批量变量更新结束时触发的事件\n         * - 事件值: 'mag_variable_update_ended'\n         * - 回调签名: (variables: MvuData, out_is_updated: boolean) => void\n         *   - variables: 更新完成后的完整数据对象\n         *     - variables.stat_data: 最新的状态数据\n         *     - variables.display_data: 包含变化描述的显示数据\n         *     - variables.delta_data: 仅包含本次更新变化的数据\n         * - 触发时机: parseMessage 或 LLM消息回复结束 完成所有命令的处理后\n         * - 典型用途:\n         *   - 对变量的值进行回滚\n         *   - 根据变量的变更更新事件触发、变量取值（如日替后更新每日任务等）\n         *\n         * @example\n         * // 1. 监听单个变量更新 - 实现变量联动\n         * eventOn(Mvu.events.SINGLE_VARIABLE_UPDATED, (stat_data, path, oldValue, newValue) => {\n         *   console.log(`[变量更新] ${path}: ${oldValue} -> ${newValue}`);\n         *\n         *   // 等级提升时的连锁反应\n         *   if (path === 'player.level' && newValue > oldValue) {\n         *     const levelUp = newValue - oldValue;\n         *     // 每级增加10点生命上限\n         *     const newMaxHealth = stat_data.player.maxHealth + (levelUp * 10);\n         *     Mvu.setMvuVariable(stat_data, 'player.maxHealth', newMaxHealth, {\n         *       reason: `升级奖励(+${levelUp}级)`\n         *     });\n         *   }\n         *\n         *   // 生命值降到0时触发死亡\n         *   if (path === 'player.health' && newValue <= 0 && oldValue > 0) {\n         *     Mvu.setMvuVariable(mvuData, 'player.status', 'dead', {\n         *       reason: '生命值耗尽',\n         *       is_recursive: true  // 允许因此再次触发 events\n         *     });\n         *   }\n         * });\n         *\n         * // 2. 监听批量更新开始 - 准备UI和状态\n         * var value_snapshot = undefined;\n         * eventOn(Mvu.events.VARIABLE_UPDATE_STARTED, (variables, out_is_updated) => {\n         *   console.log('[批量更新] 开始处理变量更新...');\n         *\n         *   // 保存老值\n         *   value_snapshot = variables.stat_data.世界线变更度;\n         * });\n         *\n         * // 3. 监听批量更新结束 - 完成后处理\n         * eventOn(Mvu.events.VARIABLE_UPDATE_ENDED, (variables, out_is_updated) => {\n         *   console.log('[批量更新] 完成，是否有更新:', out_is_updated);\n         *   //使用老值覆盖，禁止llm 更新\n         *   Mvu.setMvuVariable(variables.stat_data, '世界线变更都', value_snapshot);\n         * });\n         *\n         */\n        events: variable_events,\n\n        /**\n         * 解析包含变量更新命令的消息\n         * @param message - 包含 _.set() 命令的消息字符串\n         * @param old_data - 当前的 MvuData 状态\n         * @returns 如果有变量被更新则返回新的 MvuData，否则返回 undefined\n         * @example\n         * const newData = await Mvu.parseMessage(`\n         *   _.set('player.health', 100, 80);//受到伤害\n         *   _.set('player.position', \"城镇\", \"森林\");//移动\n         * `, currentData);\n         */\n        parseMessage: async function (\n            message: string,\n            old_data: MvuData\n        ): Promise<MvuData | undefined> {\n            const variableData: VariableData = {\n                old_variables: old_data,\n            };\n            await handleVariablesInCallback(message, variableData);\n            return variableData.new_variables;\n        },\n\n        /**\n         * 获取指定作用域的 MvuData\n         * @param options - 变量选项，指定获取哪个作用域的变量（chat/message/global等）\n         * @returns MvuData 对象\n         * @example\n         * const chatData = Mvu.getMvuData({ type: 'chat' });\n         * const messageData = Mvu.getMvuData({ type: 'message', message_id: 'latest' });\n         */\n        getMvuData: function (options: VariableOption): MvuData {\n            const result = getVariables(options);\n            return result as MvuData;\n        },\n\n        /**\n         * 替换指定作用域的 MvuData\n         * @param mvu_data - 要设置的新 MvuData\n         * @param options - 变量选项，指定替换哪个作用域的变量\n         * @example\n         * await Mvu.replaceMvuData(newData, { type: 'chat' });\n         */\n        replaceMvuData: async function (mvu_data: MvuData, options: VariableOption): Promise<void> {\n            await replaceVariables(mvu_data, options);\n        },\n\n        /**\n         * 获取当前消息的 MvuData\n         * @returns 当前消息的 MvuData 对象\n         * @example\n         * const currentData = Mvu.getCurrentMvuData();\n         */\n        getCurrentMvuData: function (): MvuData {\n            const variables = getVariables({ type: 'message', message_id: getCurrentMessageId() });\n            return variables as MvuData;\n        },\n\n        /**\n         * 替换当前消息的 MvuData\n         * @param mvu_data - 要设置的新 MvuData\n         * @example\n         * await Mvu.replaceCurrentMvuData(updatedData);\n         */\n        replaceCurrentMvuData: async function (mvu_data: MvuData): Promise<void> {\n            await replaceVariables(mvu_data, {\n                type: 'message',\n                message_id: getCurrentMessageId(),\n            });\n        },\n\n        /**\n         * 重新加载初始变量数据\n         * @param mvu_data - 要重新加载初始数据的 MvuData 对象\n         * @returns 是否加载成功\n         * @example\n         * const success = await Mvu.reloadInitVar(mvuData);\n         */\n        reloadInitVar: async function (mvu_data: MvuData): Promise<boolean> {\n            return await loadInitVarData(mvu_data);\n        },\n\n        /**\n         * 设置单个变量的值\n         * @param mvu_data - 要更新的 MvuData 对象\n         * @param path - 变量路径，支持嵌套路径如 \"player.health\" 或数组索引 \"items[0]\"\n         * @param new_value - 新值\n         * @param options - 可选参数\n         * @param options.reason - 更新原因，会显示在 display_data 中\n         * @param options.is_recursive - 是否触发 mag_variable_updated 事件，默认 false\n         * @returns 更新是否成功\n         * @example\n         * // 简单更新\n         * await Mvu.setMvuVariable(data, 'player.health', 80);\n         *\n         * // 带原因的更新\n         * await Mvu.setMvuVariable(data, 'player.health', 80, { reason: '受到伤害' });\n         *\n         * // 触发事件的更新\n         * await Mvu.setMvuVariable(data, 'player.level', 2, {\n         *   reason: '升级',\n         *   is_recursive: true\n         * });\n         *\n         */\n        setMvuVariable: async function (\n            mvu_data: MvuData,\n            path: string,\n            new_value: any,\n            { reason = '', is_recursive = false }: { reason?: string; is_recursive?: boolean } = {}\n        ): Promise<boolean> {\n            return await updateVariable(mvu_data.stat_data, path, new_value, reason, is_recursive);\n        },\n\n        /**\n         * 获取变量的值\n         * @param mvu_data - MvuData 对象\n         * @param path - 变量路径，支持嵌套路径\n         * @param options - 可选参数\n         * @param options.category - 从哪个数据类别获取：'stat'(默认)/'display'/'delta'\n         * @param options.default_value - 当路径不存在时返回的默认值\n         * @returns 变量值。如果是 ValueWithDescription 类型，返回第一个元素（实际值）\n         * @example\n         * // 获取 stat_data 中的值\n         * const health = Mvu.getMvuVariable(data, 'player.health');\n         *\n         * // 获取 display_data 中的显示值\n         * const healthDisplay = Mvu.getMvuVariable(data, 'player.health', {\n         *   category: 'display'\n         * });\n         *\n         * // 带默认值\n         * const score = Mvu.getMvuVariable(data, 'player.score', {\n         *   default_value: 0\n         * });\n         */\n        getMvuVariable: function (\n            mvu_data: MvuData,\n            path: string,\n            {\n                category = 'stat',\n                default_value = undefined,\n            }: { category?: 'stat' | 'display' | 'delta'; default_value?: any } = {}\n        ): any {\n            let data: Record<string, any>;\n            switch (category) {\n                case 'stat':\n                    data = mvu_data.stat_data;\n                    break;\n                case 'display':\n                    data = mvu_data.display_data!;\n                    break;\n                case 'delta':\n                    data = mvu_data.delta_data!;\n                    break;\n            }\n\n            const value = _.get(data, path, default_value);\n\n            /* 如果是 VWD，取第一个元素 */\n            if (isValueWithDescription(value)) {\n                return value[0];\n            }\n\n            /* 否则直接返回值本身 */\n            return value;\n        },\n\n        /**\n         * 获取指定类别的完整数据记录\n         * @param mvu_data - MvuData 对象\n         * @param category - 数据类别：'stat'/'display'/'delta'\n         * @returns 对应类别的完整数据记录对象\n         * @example\n         * // 获取所有状态数据\n         * const allStatData = Mvu.getRecordFromMvuData(data, 'stat');\n         *\n         * // 获取所有显示数据\n         * const allDisplayData = Mvu.getRecordFromMvuData(data, 'display');\n         *\n         * // 获取所有增量数据\n         * const allDeltaData = Mvu.getRecordFromMvuData(data, 'delta');\n         *\n         * @note 通常用于 LLM 准备 foreach 数据时使用\n         */\n        getRecordFromMvuData: function (\n            mvu_data: MvuData,\n            category: 'stat' | 'display' | 'delta'\n        ): Record<string, any> {\n            return extractRecord(category, mvu_data);\n        },\n    };\n    return mvu;\n}\n\nexport type MVU = ReturnType<typeof createMVU>;\n\nexport type Mvu = MVU;\n\nexport function exportGlobals() {\n    const mvu = createMVU();\n    _.set(window, 'Mvu', mvu);\n    _.set(window.parent, 'Mvu', mvu);\n}\n","import { registerButtons } from '@/button';\nimport { exportGlobals } from '@/export_globals';\nimport { handleVariablesInCallback, handleVariablesInMessage, updateVariable } from '@/function';\nimport { exported_events } from '@/variable_def';\nimport { initCheck } from '@/variable_init';\nimport { GetSettings } from '@/settings';\nimport { compare } from 'compare-versions';\n\n$(async () => {\n    registerButtons();\n    exportGlobals();\n    eventOn(tavern_events.GENERATION_STARTED, initCheck);\n    eventOn(tavern_events.MESSAGE_SENT, initCheck);\n    eventOn(tavern_events.MESSAGE_SENT, handleVariablesInMessage);\n    eventOn(tavern_events.MESSAGE_RECEIVED, handleVariablesInMessage);\n    eventOn(exported_events.INVOKE_MVU_PROCESS, handleVariablesInCallback);\n    eventOn(exported_events.UPDATE_VARIABLE, updateVariable);\n    await GetSettings();\n\n    // 导出到窗口，便于调试\n    try {\n        _.set(parent.window, 'handleVariablesInMessage', handleVariablesInMessage);\n    } catch (_e) {\n        /* empty */\n    }\n\n    try {\n        // 输出构建信息\n        toastr.info(\n            `构建信息: ${__BUILD_DATE__ ?? 'Unknown'} (${__COMMIT_ID__ ?? 'Unknown'})`,\n            'MVU加载成功'\n        );\n        const version = await getTavernHelperVersion();\n        if (compare(version, '3.2.13', '<')) {\n            toastr.warning(\n                '酒馆助手版本过低, 可能无法正常处理, 请更新至 3.2.13 或更高版本（建议保持酒馆助手最新）'\n            );\n        }\n    } catch (_e) {\n        /* empty */\n    }\n});\n\n$(window).on('unload', () => {\n    eventRemoveListener(tavern_events.GENERATION_STARTED, initCheck);\n    eventRemoveListener(tavern_events.MESSAGE_SENT, initCheck);\n    eventRemoveListener(tavern_events.MESSAGE_SENT, handleVariablesInMessage);\n    eventRemoveListener(tavern_events.MESSAGE_RECEIVED, handleVariablesInMessage);\n    eventRemoveListener(exported_events.INVOKE_MVU_PROCESS, handleVariablesInCallback);\n});\n"],"names":["assertVWD","_flag","_v","isValueWithDescriptionStatData","value","Array","isArray","length","isArraySchema","type","isObjectSchema","variable_events","SINGLE_VARIABLE_UPDATED","VARIABLE_UPDATE_ENDED","VARIABLE_UPDATE_STARTED","exported_events","__WEBPACK_EXTERNAL_MODULE_https_testingcf_jsdelivr_net_npm_mathjs_esm_aec644b1__","EXTENSIBLE_MARKER","generateSchema","data","oldSchemaNode","parentRecursiveExtensible","oldElementType","template","isExtensible","isRecursiveExtensible","extensible","recursiveExtensible","elementType","console","error","metaElementIndex","findIndex","item","_","isObject","isDate","metaElement","undefined","$meta","splice","log","markerIndex","indexOf","schema_node","typedData","oldProperties","oldExtensible","oldRecursiveExtensible","properties","schemaNode","parentMeta","key","oldChildNode","childRecursiveExtensible","childSchema","isRequired","required","includes","dataType","getSchemaForPath","schema","path","pathSegments","toPath","currentSchema","segment","test","reconcileAndApplySchema","variables","newSchema","cloneDeep","stat_data","newSchemaWithProps","strictTemplate","strictSet","concatTemplateArray","has","cleanUpMetadata","i","DefaultSetting","variable_option","script_id","getScriptId","FallbackStringBoolean","settings","stringBooleanFields","updateVersionInfo","e","async","GetSettings","getVariables","VerifySettings","mergedSettings","merge","replaceVariables","isEqual","trimQuotesAndBackslashes","str","isString","replace","applyTemplate","strict_array_cast","array_merge_concat","value_is_object","value_is_array","template_is_array","concat","parseCommandValue","valStr","trimmed","trim","JSON","parse","startsWith","endsWith","result","Function","err","scope","Math","math","toString","parseFloat","toPrecision","YAML","findMatchingCloseParen","startPos","parenCount","inQuote","quoteChar","char","prevChar","parseParameters","paramsString","params","currentParam","bracketCount","braceCount","push","getLastValidVariable","message_id","structuredClone","SillyTavern","chat","slice","map","chat_message","get","swipe_id","findLast","pathFix","segments","currentSegment","inQuotes","join","updateVariable","new_value","reason","is_recursive","display_data","$internal","delta_data","currentValue","oldValue","set","reason_str","display_str","stringify","info","eventEmit","stringNewValue","updateVariables","current_message_content","out_is_modifed","out_status","delta_status","commands","inputText","results","setMatch","substring","match","index","commandType","setStart","openParen","closeParen","endPos","comment","potentialComment","fullMatch","isValid","command","args","extractCommands","substitudeMacros","error_info","current_command","variable_modified","outError","message","warn","error_last","error_command","strict_template","concat_template_array","strict_set","newValue","Date","toISOString","isPathVWD","Number","oldValueCopy","finalNewValue","targetPath","existingValue","targetSchema","newKey","String","successful","valueToAssign","collection","keyOrIndex","keyOrIndexToRemove","containerPath","pathParts","lastPart","pop","containerSchema","keyString","targetToRemove","itemRemoved","unset","originalArray","indexToRemove","keys","Object","keyToRemove","initialValue","valueToAdd","isVWD","potentialDate","parsedDate","isNaN","getTime","delta","newDate","finalValueToSet","base_command","toastr","warning","timeOut","lastExecutionTime","handleVariablesInMessage","jest","process","now","getChatMessages","at","message_content","request_message_id","chat_variables","initialized_lorebooks","insertOrAssignVariables","role","setChatMessages","refresh","handleVariablesInCallback","in_out_variable_info","old_variables","new_variables","updateDescriptions","_init_path","init_data","msg_data","target_data","forEach","current_path","msgValue","targetObj","description","msg_array","current_target","description_path","initCheck","last_msg","last_chat_msg","include_swipes","first_msg","Error","swipes_data","getLastMessageVariables","oldArray","newObject","lorebookName","is_updated","loadInitVarData","isEmpty","generated_schema","swipes","current_swipe_data","setChatMessage","_e","dst_setting","scan_depth","context_percentage","budget_cap","min_activations","max_depth","max_recursion_steps","insertion_strategy","include_names","recursive","case_sensitive","match_whole_words","use_group_scoring","overflow_alert","getLorebookSettings","setLorebookSettings","updateLorebookSettings","mvu_data","lorebook_list","enabled_lorebook_list","selected_global_lorebooks","char_lorebook","getCurrentCharPrimaryLorebook","getEnabledLorebookList","current_lorebook","init_entries","getLorebookEntries","entry","toLowerCase","content","parsedData","parseError","e2","e3","buttons","lastButtonExecutionTime","reloadInit","latest_init_data","getLastMessageId","latest_msg_data","merged_data","success","registerButtons","current_buttons","getScriptButtons","current_button_names","b","name","button","filter","visible","replaceScriptButtons","addButtons","eventOnButton","deleteVariable","callGenericPopup","POPUP_TYPE","INPUT","depth","parseInt","variable","saveChat","then","createMVU","events","parseMessage","old_data","variableData","getMvuData","options","replaceMvuData","getCurrentMvuData","getCurrentMessageId","replaceCurrentMvuData","reloadInitVar","setMvuVariable","getMvuVariable","category","default_value","isValueWithDescription","getRecordFromMvuData","game_data","extractRecord","$","mvu","window","parent","exportGlobals","eventOn","tavern_events","GENERATION_STARTED","MESSAGE_SENT","MESSAGE_RECEIVED","version","getTavernHelperVersion","compare","on","eventRemoveListener"],"sourceRoot":""}